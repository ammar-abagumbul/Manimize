{
  "doc_id": "3f3b09ee5b7219e7be0536bed150a32b",
  "url": "https://docs.manim.community/en/latest/reference/manim.mobject.types.point_cloud_mobject.PMobject.html",
  "title": "PMobject - Manim Community v0.19.0",
  "content": "PMobject[¶](#pmobject \"Link to this heading\")\n=============================================\nQualified name: `manim.mobject.types.point\\_cloud\\_mobject.PMobject`\n*class* PMobject(*stroke\\_width\\=4*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject)[¶](#manim.mobject.types.point_cloud_mobject.PMobject \"Link to this definition\")\nBases: [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nA disc made of a cloud of Dots\nExamples\nExample: PMobjectExample [¶](#pmobjectexample)\n![../_images/PMobjectExample-1.png](../_images/PMobjectExample-1.png)\n```\nfrom manim import *\nclass PMobjectExample(Scene):\n    def construct(self):\n        pG = PGroup()  # This is just a collection of PMobject's\n        # As the scale factor increases, the number of points\n        # removed increases.\n        for sf in range(1, 9 + 1):\n            p = PointCloudDot(density=20, radius=1).thin_out(sf)\n            # PointCloudDot is a type of PMobject\n            # and can therefore be added to a PGroup\n            pG.add(p)\n        # This organizes all the shapes in a grid.\n        pG.arrange_in_grid()\n        self.add(pG)\n```\n```\nclass PMobjectExample(Scene):\n    def construct(self):\n        pG = PGroup()  # This is just a collection of PMobject's\n        # As the scale factor increases, the number of points\n        # removed increases.\n        for sf in range(1, 9 + 1):\n            p = PointCloudDot(density=20, radius=1).thin_out(sf)\n            # PointCloudDot is a type of PMobject\n            # and can therefore be added to a PGroup\n            pG.add(p)\n        # This organizes all the shapes in a grid.\n        pG.arrange_in_grid()\n        self.add(pG)\n```\nMethods\n| [`add_points`](#manim.mobject.types.point_cloud_mobject.PMobject.add_points \"manim.mobject.types.point_cloud_mobject.PMobject.add_points\") | Add points. |\n| --- | --- |\n| `align_points_with_larger` |  |\n| `fade_to` |  |\n| `filter_out` |  |\n| `get_all_rgbas` |  |\n| `get_array_attrs` |  |\n| [`get_color`](#manim.mobject.types.point_cloud_mobject.PMobject.get_color \"manim.mobject.types.point_cloud_mobject.PMobject.get_color\") | Returns the color of the [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") |\n| [`get_mobject_type_class`](#manim.mobject.types.point_cloud_mobject.PMobject.get_mobject_type_class \"manim.mobject.types.point_cloud_mobject.PMobject.get_mobject_type_class\") | Return the base class of this mobject type. |\n| [`get_point_mobject`](#manim.mobject.types.point_cloud_mobject.PMobject.get_point_mobject \"manim.mobject.types.point_cloud_mobject.PMobject.get_point_mobject\") | The simplest [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") to be transformed to or from self. |\n| `get_stroke_width` |  |\n| `ingest_submobjects` |  |\n| `interpolate_color` |  |\n| `match_colors` |  |\n| `point_from_proportion` |  |\n| `pointwise_become_partial` |  |\n| [`reset_points`](#manim.mobject.types.point_cloud_mobject.PMobject.reset_points \"manim.mobject.types.point_cloud_mobject.PMobject.reset_points\") | Sets `points` to be an empty array. |\n| [`set_color`](#manim.mobject.types.point_cloud_mobject.PMobject.set_color \"manim.mobject.types.point_cloud_mobject.PMobject.set_color\") | Condition is function which takes in one arguments, (x, y, z). |\n| [`set_color_by_gradient`](#manim.mobject.types.point_cloud_mobject.PMobject.set_color_by_gradient \"manim.mobject.types.point_cloud_mobject.PMobject.set_color_by_gradient\") |  |\n| `set_colors_by_radial_gradient` |  |\n| `set_stroke_width` |  |\n| [`sort_points`](#manim.mobject.types.point_cloud_mobject.PMobject.sort_points \"manim.mobject.types.point_cloud_mobject.PMobject.sort_points\") | Function is any map from R^3 to R |\n| [`thin_out`](#manim.mobject.types.point_cloud_mobject.PMobject.thin_out \"manim.mobject.types.point_cloud_mobject.PMobject.thin_out\") | Removes all but every nth point for n \\= factor |\nAttributes\n| `animate` | Used to animate the application of any method of `self`. |\n| --- | --- |\n| `animation_overrides` |  |\n| `depth` | The depth of the mobject. |\n| `height` | The height of the mobject. |\n| `width` | The width of the mobject. |\nParameters:\n* **stroke\\_width** (*int*)\n* **kwargs** (*Any*)\n\\_original\\_\\_init\\_\\_(*stroke\\_width\\=4*, *\\*\\*kwargs*)[¶](#manim.mobject.types.point_cloud_mobject.PMobject._original__init__ \"Link to this definition\")\nInitialize self. See help(type(self)) for accurate signature.\nParameters:\n* **stroke\\_width** (*int*)\n* **kwargs** (*Any*)\nReturn type:\nNone\nadd\\_points(*points*, *rgbas\\=None*, *color\\=None*, *alpha\\=1*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.add_points)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.add_points \"Link to this definition\")\nAdd points.\nPoints must be a Nx3 numpy array.\nRgbas must be a Nx4 numpy array if it is not None.\nParameters:\n* **points** (*npt.NDArray*)\n* **rgbas** (*npt.NDArray* *\\|* *None*)\n* **color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*)\n* **alpha** (*float*)\nReturn type:\nSelf\nget\\_color()[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.get_color)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.get_color \"Link to this definition\")\nReturns the color of the [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nExamples\n```\n>>> from manim import Square, RED\n>>> Square(color=RED).get_color() == RED\nTrue\n```\nReturn type:\n[*ManimColor*](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\")\n*static* get\\_mobject\\_type\\_class()[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.get_mobject_type_class)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.get_mobject_type_class \"Link to this definition\")\nReturn the base class of this mobject type.\nReturn type:\ntype\\[[*PMobject*](#manim.mobject.types.point_cloud_mobject.PMobject \"manim.mobject.types.point_cloud_mobject.PMobject\")]\nget\\_point\\_mobject(*center\\=None*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.get_point_mobject)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.get_point_mobject \"Link to this definition\")\nThe simplest [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") to be transformed to or from self.\nShould by a point of the appropriate type\nParameters:\n**center** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\") *\\|* *None*)\nReturn type:\n[Point](manim.mobject.types.point_cloud_mobject.Point.html#manim.mobject.types.point_cloud_mobject.Point \"manim.mobject.types.point_cloud_mobject.Point\")\nreset\\_points()[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.reset_points)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.reset_points \"Link to this definition\")\nSets `points` to be an empty array.\nReturn type:\nSelf\nset\\_color(*color\\=ManimColor('\\#FFFF00')*, *family\\=True*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.set_color)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.set_color \"Link to this definition\")\nCondition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color\nParameters:\n* **color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\"))\n* **family** (*bool*)\nReturn type:\nSelf\nset\\_color\\_by\\_gradient(*\\*colors*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.set_color_by_gradient)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.set_color_by_gradient \"Link to this definition\")\nParameters:\n* **colors** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\")) – The colors to use for the gradient. Use like set\\_color\\_by\\_gradient(RED, BLUE, GREEN).\n* **ManimColor.parse****(****color****)** (*self.color \\=*)\n* **self** (*return*)\nReturn type:\nSelf\nsort\\_points(*function\\=\\<function PMobject.\\<lambda\\>\\>*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.sort_points)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.sort_points \"Link to this definition\")\nFunction is any map from R^3 to R\nParameters:\n**function** (*Callable**\\[**\\[**npt.NDArray**\\[*[*ManimFloat*](manim.typing.html#manim.typing.ManimFloat \"manim.typing.ManimFloat\")*]**]**,* *float**]*)\nReturn type:\nSelf\nthin\\_out(*factor\\=5*)[\\[source]](../_modules/manim/mobject/types/point_cloud_mobject.html#PMobject.thin_out)[¶](#manim.mobject.types.point_cloud_mobject.PMobject.thin_out \"Link to this definition\")\nRemoves all but every nth point for n \\= factor\nParameters:\n**factor** (*int*)\nReturn type:\nSelf",
  "scraped_at": "2025-06-24T17:58:59.702808",
  "content_length": 9225,
  "domain": "docs.manim.community",
  "word_count": 695,
  "inspection_status": "approved",
  "filename": "PMobject - Manim Community v0.19.0_20250624_175859.json",
  "saved_at": "2025-06-24T17:58:59.702875",
  "approved_at": "2025-06-25T17:18:58.286756"
}