{
  "doc_id": "1d474996c822cf9570c799d9c1209900",
  "url": "https://docs.manim.community/en/latest/reference/manim.mobject.types.vectorized_mobject.VMobject.html",
  "title": "VMobject - Manim Community v0.19.0",
  "content": "VMobject[¶](#vmobject \"Link to this heading\")\n=============================================\nQualified name: `manim.mobject.types.vectorized\\_mobject.VMobject`\n*class* VMobject(*fill\\_color\\=None*, *fill\\_opacity\\=0\\.0*, *stroke\\_color\\=None*, *stroke\\_opacity\\=1\\.0*, *stroke\\_width\\=4*, *background\\_stroke\\_color\\=ManimColor('\\#000000')*, *background\\_stroke\\_opacity\\=1\\.0*, *background\\_stroke\\_width\\=0*, *sheen\\_factor\\=0\\.0*, *joint\\_type\\=None*, *sheen\\_direction\\=array(\\[\\-1\\., 1\\., 0\\.])*, *close\\_new\\_points\\=False*, *pre\\_function\\_handle\\_to\\_anchor\\_scale\\_factor\\=0\\.01*, *make\\_smooth\\_after\\_applying\\_functions\\=False*, *background\\_image\\=None*, *shade\\_in\\_3d\\=False*, *tolerance\\_for\\_point\\_equality\\=1e\\-06*, *n\\_points\\_per\\_cubic\\_curve\\=4*, *cap\\_style\\=CapStyleType.AUTO*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject)[¶](#manim.mobject.types.vectorized_mobject.VMobject \"Link to this definition\")\nBases: [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nA vectorized mobject.\nParameters:\n* **background\\_stroke\\_color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*) – The purpose of background stroke is to have something\nthat won’t overlap fill, e.g. For text against some\ntextured background.\n* **sheen\\_factor** (*float*) – When a color c is set, there will be a second color\ncomputed based on interpolating c to WHITE by with\nsheen\\_factor, and the display will gradient to this\nsecondary color in the direction of sheen\\_direction.\n* **close\\_new\\_points** (*bool*) – Indicates that it will not be displayed, but\nthat it should count in parent mobject’s path\n* **tolerance\\_for\\_point\\_equality** (*float*) – This is within a pixel\n* **joint\\_type** ([*LineJointType*](manim.constants.LineJointType.html#manim.constants.LineJointType \"manim.constants.LineJointType\") *\\|* *None*) – The line joint type used to connect the curve segments\nof this vectorized mobject. See [`LineJointType`](manim.constants.LineJointType.html#manim.constants.LineJointType \"manim.constants.LineJointType\")\nfor options.\n* **fill\\_color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*)\n* **fill\\_opacity** (*float*)\n* **stroke\\_color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*)\n* **stroke\\_opacity** (*float*)\n* **stroke\\_width** (*float*)\n* **background\\_stroke\\_opacity** (*float*)\n* **background\\_stroke\\_width** (*float*)\n* **sheen\\_direction** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\"))\n* **pre\\_function\\_handle\\_to\\_anchor\\_scale\\_factor** (*float*)\n* **make\\_smooth\\_after\\_applying\\_functions** (*bool*)\n* **background\\_image** (*Image* *\\|* *str* *\\|* *None*)\n* **shade\\_in\\_3d** (*bool*)\n* **n\\_points\\_per\\_cubic\\_curve** (*int*)\n* **cap\\_style** ([*CapStyleType*](manim.constants.CapStyleType.html#manim.constants.CapStyleType \"manim.constants.CapStyleType\"))\n* **kwargs** (*Any*)\nMethods\n| `add_cubic_bezier_curve` |  |\n| --- | --- |\n| [`add_cubic_bezier_curve_to`](#manim.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to \"manim.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to\") | Add cubic bezier curve to the path. |\n| `add_cubic_bezier_curves` |  |\n| [`add_line_to`](#manim.mobject.types.vectorized_mobject.VMobject.add_line_to \"manim.mobject.types.vectorized_mobject.VMobject.add_line_to\") | Add a straight line from the last point of VMobject to the given point. |\n| [`add_points_as_corners`](#manim.mobject.types.vectorized_mobject.VMobject.add_points_as_corners \"manim.mobject.types.vectorized_mobject.VMobject.add_points_as_corners\") | Append multiple straight lines at the end of `VMobject.points`, which connect the given `points` in order starting from the end of the current path. |\n| [`add_quadratic_bezier_curve_to`](#manim.mobject.types.vectorized_mobject.VMobject.add_quadratic_bezier_curve_to \"manim.mobject.types.vectorized_mobject.VMobject.add_quadratic_bezier_curve_to\") | Add Quadratic bezier curve to the path. |\n| [`add_smooth_curve_to`](#manim.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to \"manim.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to\") | Creates a smooth curve from given points and add it to the VMobject. |\n| `add_subpath` |  |\n| [`align_points`](#manim.mobject.types.vectorized_mobject.VMobject.align_points \"manim.mobject.types.vectorized_mobject.VMobject.align_points\") | Adds points to self and vmobject so that they both have the same number of subpaths, with corresponding subpaths each containing the same number of points. |\n| `align_rgbas` |  |\n| [`append_points`](#manim.mobject.types.vectorized_mobject.VMobject.append_points \"manim.mobject.types.vectorized_mobject.VMobject.append_points\") | Append the given `new_points` to the end of `VMobject.points`. |\n| `append_vectorized_mobject` |  |\n| `apply_function` |  |\n| [`change_anchor_mode`](#manim.mobject.types.vectorized_mobject.VMobject.change_anchor_mode \"manim.mobject.types.vectorized_mobject.VMobject.change_anchor_mode\") | Changes the anchor mode of the bezier curves. |\n| `clear_points` |  |\n| `close_path` |  |\n| `color_using_background_image` |  |\n| `consider_points_equals` |  |\n| [`consider_points_equals_2d`](#manim.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d \"manim.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d\") | Determine if two points are close enough to be considered equal. |\n| `fade` |  |\n| [`force_direction`](#manim.mobject.types.vectorized_mobject.VMobject.force_direction \"manim.mobject.types.vectorized_mobject.VMobject.force_direction\") | Makes sure that points are either directed clockwise or counterclockwise. |\n| [`gen_cubic_bezier_tuples_from_points`](#manim.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points \"manim.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points\") | Returns the bezier tuples from an array of points. |\n| `gen_subpaths_from_points_2d` |  |\n| [`generate_rgbas_array`](#manim.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array \"manim.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array\") | First arg can be either a color, or a tuple/list of colors. |\n| [`get_anchors`](#manim.mobject.types.vectorized_mobject.VMobject.get_anchors \"manim.mobject.types.vectorized_mobject.VMobject.get_anchors\") | Returns the anchors of the curves forming the VMobject. |\n| [`get_anchors_and_handles`](#manim.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles \"manim.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles\") | Returns anchors1, handles1, handles2, anchors2, where (anchors1\\[i], handles1\\[i], handles2\\[i], anchors2\\[i]) will be four points defining a cubic bezier curve for any i in range(0, len(anchors1\\)) |\n| [`get_arc_length`](#manim.mobject.types.vectorized_mobject.VMobject.get_arc_length \"manim.mobject.types.vectorized_mobject.VMobject.get_arc_length\") | Return the approximated length of the whole curve. |\n| `get_background_image` |  |\n| [`get_color`](#manim.mobject.types.vectorized_mobject.VMobject.get_color \"manim.mobject.types.vectorized_mobject.VMobject.get_color\") | Returns the color of the [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") |\n| `get_cubic_bezier_tuples` |  |\n| `get_cubic_bezier_tuples_from_points` |  |\n| [`get_curve_functions`](#manim.mobject.types.vectorized_mobject.VMobject.get_curve_functions \"manim.mobject.types.vectorized_mobject.VMobject.get_curve_functions\") | Gets the functions for the curves of the mobject. |\n| [`get_curve_functions_with_lengths`](#manim.mobject.types.vectorized_mobject.VMobject.get_curve_functions_with_lengths \"manim.mobject.types.vectorized_mobject.VMobject.get_curve_functions_with_lengths\") | Gets the functions and lengths of the curves for the mobject. |\n| [`get_direction`](#manim.mobject.types.vectorized_mobject.VMobject.get_direction \"manim.mobject.types.vectorized_mobject.VMobject.get_direction\") | Uses [`shoelace_direction()`](manim.utils.space_ops.html#manim.utils.space_ops.shoelace_direction \"manim.utils.space_ops.shoelace_direction\") to calculate the direction. |\n| [`get_end_anchors`](#manim.mobject.types.vectorized_mobject.VMobject.get_end_anchors \"manim.mobject.types.vectorized_mobject.VMobject.get_end_anchors\") | Return the end anchors of the bezier curves. |\n| [`get_fill_color`](#manim.mobject.types.vectorized_mobject.VMobject.get_fill_color \"manim.mobject.types.vectorized_mobject.VMobject.get_fill_color\") | If there are multiple colors (for gradient) this returns the first one |\n| `get_fill_colors` |  |\n| `get_fill_opacities` |  |\n| [`get_fill_opacity`](#manim.mobject.types.vectorized_mobject.VMobject.get_fill_opacity \"manim.mobject.types.vectorized_mobject.VMobject.get_fill_opacity\") | If there are multiple opacities, this returns the first |\n| `get_fill_rgbas` |  |\n| `get_gradient_start_and_end_points` |  |\n| `get_group_class` |  |\n| `get_last_point` |  |\n| [`get_mobject_type_class`](#manim.mobject.types.vectorized_mobject.VMobject.get_mobject_type_class \"manim.mobject.types.vectorized_mobject.VMobject.get_mobject_type_class\") | Return the base class of this mobject type. |\n| [`get_nth_curve_function`](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function \"manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function\") | Returns the expression of the nth curve. |\n| [`get_nth_curve_function_with_length`](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function_with_length \"manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function_with_length\") | Returns the expression of the nth curve along with its (approximate) length. |\n| [`get_nth_curve_length`](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_length \"manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_length\") | Returns the (approximate) length of the nth curve. |\n| [`get_nth_curve_length_pieces`](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_length_pieces \"manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_length_pieces\") | Returns the array of short line lengths used for length approximation. |\n| [`get_nth_curve_points`](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_points \"manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_points\") | Returns the points defining the nth curve of the vmobject. |\n| [`get_num_curves`](#manim.mobject.types.vectorized_mobject.VMobject.get_num_curves \"manim.mobject.types.vectorized_mobject.VMobject.get_num_curves\") | Returns the number of curves of the vmobject. |\n| [`get_point_mobject`](#manim.mobject.types.vectorized_mobject.VMobject.get_point_mobject \"manim.mobject.types.vectorized_mobject.VMobject.get_point_mobject\") | The simplest [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") to be transformed to or from self. |\n| `get_points_defining_boundary` |  |\n| `get_sheen_direction` |  |\n| `get_sheen_factor` |  |\n| [`get_start_anchors`](#manim.mobject.types.vectorized_mobject.VMobject.get_start_anchors \"manim.mobject.types.vectorized_mobject.VMobject.get_start_anchors\") | Returns the start anchors of the bezier curves. |\n| `get_stroke_color` |  |\n| `get_stroke_colors` |  |\n| `get_stroke_opacities` |  |\n| `get_stroke_opacity` |  |\n| `get_stroke_rgbas` |  |\n| `get_stroke_width` |  |\n| `get_style` |  |\n| [`get_subcurve`](#manim.mobject.types.vectorized_mobject.VMobject.get_subcurve \"manim.mobject.types.vectorized_mobject.VMobject.get_subcurve\") | Returns the subcurve of the VMobject between the interval \\[a, b]. |\n| [`get_subpaths`](#manim.mobject.types.vectorized_mobject.VMobject.get_subpaths \"manim.mobject.types.vectorized_mobject.VMobject.get_subpaths\") | Returns subpaths formed by the curves of the VMobject. |\n| `get_subpaths_from_points` |  |\n| `has_new_path_started` |  |\n| [`init_colors`](#manim.mobject.types.vectorized_mobject.VMobject.init_colors \"manim.mobject.types.vectorized_mobject.VMobject.init_colors\") | Initializes the colors. |\n| [`insert_n_curves`](#manim.mobject.types.vectorized_mobject.VMobject.insert_n_curves \"manim.mobject.types.vectorized_mobject.VMobject.insert_n_curves\") | Inserts n curves to the bezier curves of the vmobject. |\n| [`insert_n_curves_to_point_list`](#manim.mobject.types.vectorized_mobject.VMobject.insert_n_curves_to_point_list \"manim.mobject.types.vectorized_mobject.VMobject.insert_n_curves_to_point_list\") | Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k \\+ n bezier curves. |\n| `interpolate_color` |  |\n| `is_closed` |  |\n| `make_jagged` |  |\n| `make_smooth` |  |\n| `match_background_image` |  |\n| `match_style` |  |\n| [`point_from_proportion`](#manim.mobject.types.vectorized_mobject.VMobject.point_from_proportion \"manim.mobject.types.vectorized_mobject.VMobject.point_from_proportion\") | Gets the point at a proportion along the path of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\"). |\n| [`pointwise_become_partial`](#manim.mobject.types.vectorized_mobject.VMobject.pointwise_become_partial \"manim.mobject.types.vectorized_mobject.VMobject.pointwise_become_partial\") | Given a 2nd [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") `vmobject`, a lower bound `a` and an upper bound `b`, modify this [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")'s points to match the portion of the Bézier spline described by `vmobject.points` with the parameter `t` between `a` and `b`. |\n| [`proportion_from_point`](#manim.mobject.types.vectorized_mobject.VMobject.proportion_from_point \"manim.mobject.types.vectorized_mobject.VMobject.proportion_from_point\") | Returns the proportion along the path of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") a particular given point is at. |\n| [`resize_points`](#manim.mobject.types.vectorized_mobject.VMobject.resize_points \"manim.mobject.types.vectorized_mobject.VMobject.resize_points\") | Resize the array of anchor points and handles to have the specified size. |\n| [`reverse_direction`](#manim.mobject.types.vectorized_mobject.VMobject.reverse_direction \"manim.mobject.types.vectorized_mobject.VMobject.reverse_direction\") | Reverts the point direction by inverting the point order. |\n| [`rotate`](#manim.mobject.types.vectorized_mobject.VMobject.rotate \"manim.mobject.types.vectorized_mobject.VMobject.rotate\") | Rotates the [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") around a specified axis and point. |\n| [`rotate_sheen_direction`](#manim.mobject.types.vectorized_mobject.VMobject.rotate_sheen_direction \"manim.mobject.types.vectorized_mobject.VMobject.rotate_sheen_direction\") | Rotates the direction of the applied sheen. |\n| [`scale`](#manim.mobject.types.vectorized_mobject.VMobject.scale \"manim.mobject.types.vectorized_mobject.VMobject.scale\") | Scale the size by a factor. |\n| [`scale_handle_to_anchor_distances`](#manim.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances \"manim.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances\") | If the distance between a given handle point H and its associated anchor point A is d, then it changes H to be a distances factor\\*d away from A, but so that the line from A to H doesn't change. |\n| [`set_anchors_and_handles`](#manim.mobject.types.vectorized_mobject.VMobject.set_anchors_and_handles \"manim.mobject.types.vectorized_mobject.VMobject.set_anchors_and_handles\") | Given two sets of anchors and handles, process them to set them as anchors and handles of the VMobject. |\n| `set_background_stroke` |  |\n| [`set_cap_style`](#manim.mobject.types.vectorized_mobject.VMobject.set_cap_style \"manim.mobject.types.vectorized_mobject.VMobject.set_cap_style\") | Sets the cap style of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\"). |\n| [`set_color`](#manim.mobject.types.vectorized_mobject.VMobject.set_color \"manim.mobject.types.vectorized_mobject.VMobject.set_color\") | Condition is function which takes in one arguments, (x, y, z). |\n| [`set_fill`](#manim.mobject.types.vectorized_mobject.VMobject.set_fill \"manim.mobject.types.vectorized_mobject.VMobject.set_fill\") | Set the fill color and fill opacity of a [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\"). |\n| `set_opacity` |  |\n| `set_points` |  |\n| [`set_points_as_corners`](#manim.mobject.types.vectorized_mobject.VMobject.set_points_as_corners \"manim.mobject.types.vectorized_mobject.VMobject.set_points_as_corners\") | Given an array of points, set them as corners of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\"). |\n| `set_points_smoothly` |  |\n| `set_shade_in_3d` |  |\n| [`set_sheen`](#manim.mobject.types.vectorized_mobject.VMobject.set_sheen \"manim.mobject.types.vectorized_mobject.VMobject.set_sheen\") | Applies a color gradient from a direction. |\n| [`set_sheen_direction`](#manim.mobject.types.vectorized_mobject.VMobject.set_sheen_direction \"manim.mobject.types.vectorized_mobject.VMobject.set_sheen_direction\") | Sets the direction of the applied sheen. |\n| `set_stroke` |  |\n| `set_style` |  |\n| [`start_new_path`](#manim.mobject.types.vectorized_mobject.VMobject.start_new_path \"manim.mobject.types.vectorized_mobject.VMobject.start_new_path\") | Append a `point` to the `VMobject.points`, which will be the beginning of a new Bézier curve in the path given by the points. |\n| `update_rgbas_array` |  |\nAttributes\n| `animate` | Used to animate the application of any method of `self`. |\n| --- | --- |\n| `animation_overrides` |  |\n| `color` |  |\n| `depth` | The depth of the mobject. |\n| [`fill_color`](#manim.mobject.types.vectorized_mobject.VMobject.fill_color \"manim.mobject.types.vectorized_mobject.VMobject.fill_color\") | If there are multiple colors (for gradient) this returns the first one |\n| `height` | The height of the mobject. |\n| `n_points_per_curve` |  |\n| `sheen_factor` |  |\n| `stroke_color` |  |\n| `width` | The width of the mobject. |\n\\_assert\\_valid\\_submobjects(*submobjects*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject._assert_valid_submobjects)[¶](#manim.mobject.types.vectorized_mobject.VMobject._assert_valid_submobjects \"Link to this definition\")\nCheck that all submobjects are actually instances of\n`Mobject`, and that none of them is `self` (a\n`Mobject` cannot contain itself).\nThis is an auxiliary function called when adding Mobjects to the\n`submobjects` list.\nThis function is intended to be overridden by subclasses such as\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\"), which should assert that only other VMobjects\nmay be added into it.\nParameters:\n**submobjects** (*Iterable**\\[*[*VMobject*](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")*]*) – The list containing values to validate.\nReturns:\nThe Mobject itself.\nReturn type:\n`Mobject`\nRaises:\n* **TypeError** – If any of the values in submobjects is not a `Mobject`.\n* **ValueError** – If there was an attempt to add a `Mobject` as its own\n submobject.\n\\_gen\\_subpaths\\_from\\_points(*points*, *filter\\_func*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject._gen_subpaths_from_points)[¶](#manim.mobject.types.vectorized_mobject.VMobject._gen_subpaths_from_points \"Link to this definition\")\nGiven an array of points defining the bezier curves of the vmobject, return subpaths formed by these points.\nHere, Two bezier curves form a path if at least two of their anchors are evaluated True by the relation defined by filter\\_func.\nThe algorithm every bezier tuple (anchors and handles) in `self.points` (by regrouping each n elements, where\nn is the number of points per cubic curve)), and evaluate the relation between two anchors with filter\\_func.\nNOTE : The filter\\_func takes an int n as parameter, and will evaluate the relation between points\\[n] and points\\[n \\- 1]. This should probably be changed so\nthe function takes two points as parameters.\nParameters:\n* **points** ([*CubicBezierPath*](manim.typing.html#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\")) – points defining the bezier curve.\n* **filter\\_func** (*Callable**\\[**\\[**int**]**,* *bool**]*) – Filter\\-func defining the relation.\nReturns:\nsubpaths formed by the points.\nReturn type:\nIterable\\[[CubicSpline](manim.typing.html#manim.typing.CubicSpline \"manim.typing.CubicSpline\")]\n\\_original\\_\\_init\\_\\_(*fill\\_color\\=None*, *fill\\_opacity\\=0\\.0*, *stroke\\_color\\=None*, *stroke\\_opacity\\=1\\.0*, *stroke\\_width\\=4*, *background\\_stroke\\_color\\=ManimColor('\\#000000')*, *background\\_stroke\\_opacity\\=1\\.0*, *background\\_stroke\\_width\\=0*, *sheen\\_factor\\=0\\.0*, *joint\\_type\\=None*, *sheen\\_direction\\=array(\\[\\-1\\., 1\\., 0\\.])*, *close\\_new\\_points\\=False*, *pre\\_function\\_handle\\_to\\_anchor\\_scale\\_factor\\=0\\.01*, *make\\_smooth\\_after\\_applying\\_functions\\=False*, *background\\_image\\=None*, *shade\\_in\\_3d\\=False*, *tolerance\\_for\\_point\\_equality\\=1e\\-06*, *n\\_points\\_per\\_cubic\\_curve\\=4*, *cap\\_style\\=CapStyleType.AUTO*, *\\*\\*kwargs*)[¶](#manim.mobject.types.vectorized_mobject.VMobject._original__init__ \"Link to this definition\")\nInitialize self. See help(type(self)) for accurate signature.\nParameters:\n* **fill\\_color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*)\n* **fill\\_opacity** (*float*)\n* **stroke\\_color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*)\n* **stroke\\_opacity** (*float*)\n* **stroke\\_width** (*float*)\n* **background\\_stroke\\_color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*)\n* **background\\_stroke\\_opacity** (*float*)\n* **background\\_stroke\\_width** (*float*)\n* **sheen\\_factor** (*float*)\n* **joint\\_type** ([*LineJointType*](manim.constants.LineJointType.html#manim.constants.LineJointType \"manim.constants.LineJointType\") *\\|* *None*)\n* **sheen\\_direction** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\"))\n* **close\\_new\\_points** (*bool*)\n* **pre\\_function\\_handle\\_to\\_anchor\\_scale\\_factor** (*float*)\n* **make\\_smooth\\_after\\_applying\\_functions** (*bool*)\n* **background\\_image** (*Image* *\\|* *str* *\\|* *None*)\n* **shade\\_in\\_3d** (*bool*)\n* **tolerance\\_for\\_point\\_equality** (*float*)\n* **n\\_points\\_per\\_cubic\\_curve** (*int*)\n* **cap\\_style** ([*CapStyleType*](manim.constants.CapStyleType.html#manim.constants.CapStyleType \"manim.constants.CapStyleType\"))\n* **kwargs** (*Any*)\nadd\\_cubic\\_bezier\\_curve\\_to(*handle1*, *handle2*, *anchor*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.add_cubic_bezier_curve_to)[¶](#manim.mobject.types.vectorized_mobject.VMobject.add_cubic_bezier_curve_to \"Link to this definition\")\nAdd cubic bezier curve to the path.\nNOTE : the first anchor is not a parameter as by default the end of the last sub\\-path!\nParameters:\n* **handle1** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – first handle\n* **handle2** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – second handle\n* **anchor** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – anchor\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nadd\\_line\\_to(*point*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.add_line_to)[¶](#manim.mobject.types.vectorized_mobject.VMobject.add_line_to \"Link to this definition\")\nAdd a straight line from the last point of VMobject to the given point.\nParameters:\n**point** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – The end of the straight line.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nadd\\_points\\_as\\_corners(*points*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.add_points_as_corners)[¶](#manim.mobject.types.vectorized_mobject.VMobject.add_points_as_corners \"Link to this definition\")\nAppend multiple straight lines at the end of\n`VMobject.points`, which connect the given `points` in order\nstarting from the end of the current path. These `points` would be\ntherefore the corners of the new polyline appended to the path.\nParameters:\n**points** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")) – An array of 3D points representing the corners of the polyline to\nappend to `VMobject.points`.\nReturns:\nThe VMobject itself, after appending the straight lines to its\npath.\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nadd\\_quadratic\\_bezier\\_curve\\_to(*handle*, *anchor*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.add_quadratic_bezier_curve_to)[¶](#manim.mobject.types.vectorized_mobject.VMobject.add_quadratic_bezier_curve_to \"Link to this definition\")\nAdd Quadratic bezier curve to the path.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nParameters:\n* **handle** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\"))\n* **anchor** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\"))\nadd\\_smooth\\_curve\\_to(*\\*points*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.add_smooth_curve_to)[¶](#manim.mobject.types.vectorized_mobject.VMobject.add_smooth_curve_to \"Link to this definition\")\nCreates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\nas a handle, the second as an anchor.\nParameters:\n**points** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – Points (anchor and handle, or just anchor) to add a smooth curve from\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nRaises:\n**ValueError** – If 0 or more than 2 points are given.\nalign\\_points(*vmobject*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.align_points)[¶](#manim.mobject.types.vectorized_mobject.VMobject.align_points \"Link to this definition\")\nAdds points to self and vmobject so that they both have the same number of subpaths, with\ncorresponding subpaths each containing the same number of points.\nPoints are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\nof a single point repeated.\nParameters:\n**vmobject** ([*VMobject*](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")) – The object to align points with.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nSee also\n[`interpolate()`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject.interpolate \"manim.mobject.mobject.Mobject.interpolate\"), [`align_data()`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject.align_data \"manim.mobject.mobject.Mobject.align_data\")\nappend\\_points(*new\\_points*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.append_points)[¶](#manim.mobject.types.vectorized_mobject.VMobject.append_points \"Link to this definition\")\nAppend the given `new_points` to the end of\n`VMobject.points`.\nParameters:\n**new\\_points** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")) – An array of 3D points to append.\nReturns:\nThe VMobject itself, after appending `new_points`.\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nchange\\_anchor\\_mode(*mode*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.change_anchor_mode)[¶](#manim.mobject.types.vectorized_mobject.VMobject.change_anchor_mode \"Link to this definition\")\nChanges the anchor mode of the bezier curves. This will modify the handles.\nThere can be only two modes, “jagged”, and “smooth”.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nParameters:\n**mode** (*Literal**\\[**'jagged'**,* *'smooth'**]*)\nconsider\\_points\\_equals\\_2d(*p0*, *p1*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.consider_points_equals_2d)[¶](#manim.mobject.types.vectorized_mobject.VMobject.consider_points_equals_2d \"Link to this definition\")\nDetermine if two points are close enough to be considered equal.\nThis uses the algorithm from np.isclose(), but expanded here for the\n2D point case. NumPy is overkill for such a small question.\n:param p0: first point\n:param p1: second point\nReturns:\nwhether two points considered close.\nReturn type:\nbool\nParameters:\n* **p0** ([*Point2DLike*](manim.typing.html#manim.typing.Point2DLike \"manim.typing.Point2DLike\"))\n* **p1** ([*Point2DLike*](manim.typing.html#manim.typing.Point2DLike \"manim.typing.Point2DLike\"))\n*property* fill\\_color*: [ManimColor](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\")*[¶](#manim.mobject.types.vectorized_mobject.VMobject.fill_color \"Link to this definition\")\nIf there are multiple colors (for gradient)\nthis returns the first one\nforce\\_direction(*target\\_direction*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.force_direction)[¶](#manim.mobject.types.vectorized_mobject.VMobject.force_direction \"Link to this definition\")\nMakes sure that points are either directed clockwise or\ncounterclockwise.\nParameters:\n**target\\_direction** (*Literal**\\[**'CW'**,* *'CCW'**]*) – Either `\"CW\"` or `\"CCW\"`.\nReturn type:\nSelf\ngen\\_cubic\\_bezier\\_tuples\\_from\\_points(*points*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.gen_cubic_bezier_tuples_from_points)[¶](#manim.mobject.types.vectorized_mobject.VMobject.gen_cubic_bezier_tuples_from_points \"Link to this definition\")\nReturns the bezier tuples from an array of points.\nself.points is a list of the anchors and handles of the bezier curves of the mobject (ie \\[anchor1, handle1, handle2, anchor2, anchor3 ..])\nThis algorithm basically retrieve them by taking an element every n, where n is the number of control points\nof the bezier curve.\nParameters:\n**points** ([*CubicBezierPathLike*](manim.typing.html#manim.typing.CubicBezierPathLike \"manim.typing.CubicBezierPathLike\")) – Points from which control points will be extracted.\nReturns:\nBezier control points.\nReturn type:\ntuple\ngenerate\\_rgbas\\_array(*color*, *opacity*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.generate_rgbas_array)[¶](#manim.mobject.types.vectorized_mobject.VMobject.generate_rgbas_array \"Link to this definition\")\nFirst arg can be either a color, or a tuple/list of colors.\nLikewise, opacity can either be a float, or a tuple of floats.\nIf self.sheen\\_factor is not zero, and only\none color was passed in, a second slightly light color\nwill automatically be added for the gradient\nParameters:\n* **color** ([*ManimColor*](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\") *\\|* *list**\\[*[*ManimColor*](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\")*]*)\n* **opacity** (*float* *\\|* *Iterable**\\[**float**]*)\nReturn type:\n[*RGBA\\_Array\\_Float*](manim.typing.html#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\nget\\_anchors()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_anchors)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_anchors \"Link to this definition\")\nReturns the anchors of the curves forming the VMobject.\nReturns:\nThe anchors.\nReturn type:\n[Point3D\\_Array](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nget\\_anchors\\_and\\_handles()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_anchors_and_handles)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_anchors_and_handles \"Link to this definition\")\nReturns anchors1, handles1, handles2, anchors2,\nwhere (anchors1\\[i], handles1\\[i], handles2\\[i], anchors2\\[i])\nwill be four points defining a cubic bezier curve\nfor any i in range(0, len(anchors1\\))\nReturns:\nIterable of the anchors and handles.\nReturn type:\nlist\\[Point3D\\_Array]\nget\\_arc\\_length(*sample\\_points\\_per\\_curve\\=None*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_arc_length)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_arc_length \"Link to this definition\")\nReturn the approximated length of the whole curve.\nParameters:\n**sample\\_points\\_per\\_curve** (*int* *\\|* *None*) – Number of sample points per curve used to approximate the length. More points result in a better approximation.\nReturns:\nThe length of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nReturn type:\nfloat\nget\\_color()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_color)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_color \"Link to this definition\")\nReturns the color of the [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nExamples\n```\n>>> from manim import Square, RED\n>>> Square(color=RED).get_color() == RED\nTrue\n```\nReturn type:\n[*ManimColor*](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\")\nget\\_curve\\_functions()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_curve_functions)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_curve_functions \"Link to this definition\")\nGets the functions for the curves of the mobject.\nReturns:\nThe functions for the curves.\nReturn type:\nIterable\\[Callable\\[\\[float], [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")]]\nget\\_curve\\_functions\\_with\\_lengths(*\\*\\*kwargs*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_curve_functions_with_lengths)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_curve_functions_with_lengths \"Link to this definition\")\nGets the functions and lengths of the curves for the mobject.\nParameters:\n**\\*\\*kwargs** – The keyword arguments passed to [`get_nth_curve_function_with_length()`](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function_with_length \"manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function_with_length\")\nReturns:\nThe functions and lengths of the curves.\nReturn type:\nIterable\\[tuple\\[Callable\\[\\[float], [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")], float]]\nget\\_direction()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_direction)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_direction \"Link to this definition\")\nUses [`shoelace_direction()`](manim.utils.space_ops.html#manim.utils.space_ops.shoelace_direction \"manim.utils.space_ops.shoelace_direction\") to calculate the direction.\nThe direction of points determines in which direction the\nobject is drawn, clockwise or counterclockwise.\nExamples\nThe default direction of a [`Circle`](manim.mobject.geometry.arc.Circle.html#manim.mobject.geometry.arc.Circle \"manim.mobject.geometry.arc.Circle\") is counterclockwise:\n```\n>>> from manim import Circle\n>>> Circle().get_direction()\n'CCW'\n```\nReturns:\nEither `\"CW\"` or `\"CCW\"`.\nReturn type:\n`str`\nget\\_end\\_anchors()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_end_anchors)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_end_anchors \"Link to this definition\")\nReturn the end anchors of the bezier curves.\nReturns:\nStarting anchors\nReturn type:\n[Point3D\\_Array](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nget\\_fill\\_color()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_fill_color)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_fill_color \"Link to this definition\")\nIf there are multiple colors (for gradient)\nthis returns the first one\nReturn type:\n[*ManimColor*](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\")\nget\\_fill\\_opacity()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_fill_opacity)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_fill_opacity \"Link to this definition\")\nIf there are multiple opacities, this returns the\nfirst\nReturn type:\n[*ManimFloat*](manim.typing.html#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n*static* get\\_mobject\\_type\\_class()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_mobject_type_class)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_mobject_type_class \"Link to this definition\")\nReturn the base class of this mobject type.\nReturn type:\ntype\\[[*VMobject*](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")]\nget\\_nth\\_curve\\_function(*n*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_nth_curve_function)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function \"Link to this definition\")\nReturns the expression of the nth curve.\nParameters:\n**n** (*int*) – index of the desired curve.\nReturns:\nexpression of the nth bezier curve.\nReturn type:\nCallable\\[float, [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")]\nget\\_nth\\_curve\\_function\\_with\\_length(*n*, *sample\\_points\\=None*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_nth_curve_function_with_length)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_function_with_length \"Link to this definition\")\nReturns the expression of the nth curve along with its (approximate) length.\nParameters:\n* **n** (*int*) – The index of the desired curve.\n* **sample\\_points** (*int* *\\|* *None*) – The number of points to sample to find the length.\nReturns:\n* **curve** (*Callable\\[\\[float], Point3D]*) – The function for the nth curve.\n* **length** (`float`) – The length of the nth curve.\nReturn type:\ntuple\\[*Callable*\\[\\[float], TypeAliasForwardRef(‘\\~manim.typing.Point3D’)], float]\nget\\_nth\\_curve\\_length(*n*, *sample\\_points\\=None*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_nth_curve_length)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_length \"Link to this definition\")\nReturns the (approximate) length of the nth curve.\nParameters:\n* **n** (*int*) – The index of the desired curve.\n* **sample\\_points** (*int* *\\|* *None*) – The number of points to sample to find the length.\nReturns:\n**length** – The length of the nth curve.\nReturn type:\n`float`\nget\\_nth\\_curve\\_length\\_pieces(*n*, *sample\\_points\\=None*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_nth_curve_length_pieces)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_length_pieces \"Link to this definition\")\nReturns the array of short line lengths used for length approximation.\nParameters:\n* **n** (*int*) – The index of the desired curve.\n* **sample\\_points** (*int* *\\|* *None*) – The number of points to sample to find the length.\nReturn type:\nThe short length\\-pieces of the nth curve.\nget\\_nth\\_curve\\_points(*n*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_nth_curve_points)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_nth_curve_points \"Link to this definition\")\nReturns the points defining the nth curve of the vmobject.\nParameters:\n**n** (*int*) – index of the desired bezier curve.\nReturns:\npoints defining the nth bezier curve (anchors, handles)\nReturn type:\n[CubicBezierPoints](manim.typing.html#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\")\nget\\_num\\_curves()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_num_curves)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_num_curves \"Link to this definition\")\nReturns the number of curves of the vmobject.\nReturns:\nnumber of curves of the vmobject.\nReturn type:\nint\nget\\_point\\_mobject(*center\\=None*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_point_mobject)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_point_mobject \"Link to this definition\")\nThe simplest [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") to be transformed to or from self.\nShould by a point of the appropriate type\nParameters:\n**center** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\") *\\|* *None*)\nReturn type:\n[VectorizedPoint](manim.mobject.types.vectorized_mobject.VectorizedPoint.html#manim.mobject.types.vectorized_mobject.VectorizedPoint \"manim.mobject.types.vectorized_mobject.VectorizedPoint\")\nget\\_start\\_anchors()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_start_anchors)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_start_anchors \"Link to this definition\")\nReturns the start anchors of the bezier curves.\nReturns:\nStarting anchors\nReturn type:\n[Point3D\\_Array](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nget\\_subcurve(*a*, *b*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_subcurve)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_subcurve \"Link to this definition\")\nReturns the subcurve of the VMobject between the interval \\[a, b].\nThe curve is a VMobject itself.\nParameters:\n* **a** (*float*) – The lower bound.\n* **b** (*float*) – The upper bound.\nReturns:\nThe subcurve between of \\[a, b]\nReturn type:\n[VMobject](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nget\\_subpaths()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.get_subpaths)[¶](#manim.mobject.types.vectorized_mobject.VMobject.get_subpaths \"Link to this definition\")\nReturns subpaths formed by the curves of the VMobject.\nSubpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\nReturns:\nsubpaths.\nReturn type:\nlist\\[[CubicSpline](manim.typing.html#manim.typing.CubicSpline \"manim.typing.CubicSpline\")]\ninit\\_colors(*propagate\\_colors\\=True*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.init_colors)[¶](#manim.mobject.types.vectorized_mobject.VMobject.init_colors \"Link to this definition\")\nInitializes the colors.\nGets called upon creation. This is an empty method that can be implemented by\nsubclasses.\nParameters:\n**propagate\\_colors** (*bool*)\nReturn type:\nSelf\ninsert\\_n\\_curves(*n*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.insert_n_curves)[¶](#manim.mobject.types.vectorized_mobject.VMobject.insert_n_curves \"Link to this definition\")\nInserts n curves to the bezier curves of the vmobject.\nParameters:\n**n** (*int*) – Number of curves to insert.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\ninsert\\_n\\_curves\\_to\\_point\\_list(*n*, *points*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.insert_n_curves_to_point_list)[¶](#manim.mobject.types.vectorized_mobject.VMobject.insert_n_curves_to_point_list \"Link to this definition\")\nGiven an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k \\+ n bezier curves.\nParameters:\n* **n** (*int*) – Number of desired curves.\n* **points** ([*BezierPathLike*](manim.typing.html#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\")) – Starting points.\nReturn type:\nPoints generated.\npoint\\_from\\_proportion(*alpha*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.point_from_proportion)[¶](#manim.mobject.types.vectorized_mobject.VMobject.point_from_proportion \"Link to this definition\")\nGets the point at a proportion along the path of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nParameters:\n**alpha** (*float*) – The proportion along the the path of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nReturns:\nThe point on the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nReturn type:\n`numpy.ndarray`\nRaises:\n* **ValueError** – If `alpha` is not between 0 and 1\\.\n* **Exception** – If the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") has no points.\nExample\nExample: PointFromProportion [¶](#pointfromproportion)\n![../_images/PointFromProportion-1.png](../_images/PointFromProportion-1.png)\n```\nfrom manim import *\nclass PointFromProportion(Scene):\n    def construct(self):\n        line = Line(2*DL, 2*UR)\n        self.add(line)\n        colors = (RED, BLUE, YELLOW)\n        proportions = (1/4, 1/2, 3/4)\n        for color, proportion in zip(colors, proportions):\n            self.add(Dot(color=color).move_to(\n                    line.point_from_proportion(proportion)\n            ))\n```\n```\nclass PointFromProportion(Scene):\n    def construct(self):\n        line = Line(2*DL, 2*UR)\n        self.add(line)\n        colors = (RED, BLUE, YELLOW)\n        proportions = (1/4, 1/2, 3/4)\n        for color, proportion in zip(colors, proportions):\n            self.add(Dot(color=color).move_to(\n                    line.point_from_proportion(proportion)\n            ))\n```\npointwise\\_become\\_partial(*vmobject*, *a*, *b*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.pointwise_become_partial)[¶](#manim.mobject.types.vectorized_mobject.VMobject.pointwise_become_partial \"Link to this definition\")\nGiven a 2nd [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") `vmobject`, a lower bound `a` and\nan upper bound `b`, modify this [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")’s points to\nmatch the portion of the Bézier spline described by `vmobject.points`\nwith the parameter `t` between `a` and `b`.\nParameters:\n* **vmobject** ([*VMobject*](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")) – The [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") that will serve as a model.\n* **a** (*float*) – The lower bound for `t`.\n* **b** (*float*) – The upper bound for `t`\nReturns:\nThe [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") itself, after the transformation.\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nRaises:\n**TypeError** – If `vmobject` is not an instance of [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nproportion\\_from\\_point(*point*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.proportion_from_point)[¶](#manim.mobject.types.vectorized_mobject.VMobject.proportion_from_point \"Link to this definition\")\nReturns the proportion along the path of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\na particular given point is at.\nParameters:\n**point** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – The Cartesian coordinates of the point which may or may not lie on the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nReturns:\nThe proportion along the path of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nReturn type:\nfloat\nRaises:\n* **ValueError** – If `point` does not lie on the curve.\n* **Exception** – If the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\") has no points.\nresize\\_points(*new\\_length*, *resize\\_func\\=\\<function resize\\_array\\>*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.resize_points)[¶](#manim.mobject.types.vectorized_mobject.VMobject.resize_points \"Link to this definition\")\nResize the array of anchor points and handles to have\nthe specified size.\nParameters:\n* **new\\_length** (*int*) – The new (total) number of points.\n* **resize\\_func** (*Callable**\\[**\\[*[*Point3D\\_Array*](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")*,* *int**]**,* [*Point3D\\_Array*](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")*]*) – A function mapping a Numpy array (the points) and an integer\n(the target size) to a Numpy array. The default implementation\nis based on Numpy’s `resize` function.\nReturn type:\nSelf\nreverse\\_direction()[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.reverse_direction)[¶](#manim.mobject.types.vectorized_mobject.VMobject.reverse_direction \"Link to this definition\")\nReverts the point direction by inverting the point order.\nReturns:\nReturns self.\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nExamples\nExample: ChangeOfDirection [¶](#changeofdirection)\n```\nfrom manim import *\nclass ChangeOfDirection(Scene):\n    def construct(self):\n        ccw = RegularPolygon(5)\n        ccw.shift(LEFT)\n        cw = RegularPolygon(5)\n        cw.shift(RIGHT).reverse_direction()\n        self.play(Create(ccw), Create(cw),\n        run_time=4)\n```\n```\nclass ChangeOfDirection(Scene):\n    def construct(self):\n        ccw = RegularPolygon(5)\n        ccw.shift(LEFT)\n        cw = RegularPolygon(5)\n        cw.shift(RIGHT).reverse_direction()\n        self.play(Create(ccw), Create(cw),\n        run_time=4)\n```\nrotate(*angle*, *axis\\=array(\\[0\\., 0\\., 1\\.])*, *about\\_point\\=None*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.rotate)[¶](#manim.mobject.types.vectorized_mobject.VMobject.rotate \"Link to this definition\")\nRotates the [`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\") around a specified axis and point.\nParameters:\n* **angle** (*float*) – The angle of rotation in radians. Predefined constants such as `DEGREES`\ncan also be used to specify the angle in degrees.\n* **axis** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")) – The rotation axis (see [`Rotating`](manim.animation.rotation.Rotating.html#manim.animation.rotation.Rotating \"manim.animation.rotation.Rotating\") for more).\n* **about\\_point** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\") *\\|* *None*) – The point about which the mobject rotates. If `None`, rotation occurs around\nthe center of the mobject.\n* **\\*\\*kwargs** – Additional keyword arguments passed to `apply_points_function_about_point()`,\nsuch as `about_edge`.\nReturns:\n`self` (for method chaining)\nReturn type:\n`Mobject`\nNote\nTo animate a rotation, use [`Rotating`](manim.animation.rotation.Rotating.html#manim.animation.rotation.Rotating \"manim.animation.rotation.Rotating\") or [`Rotate`](manim.animation.rotation.Rotate.html#manim.animation.rotation.Rotate \"manim.animation.rotation.Rotate\")\ninstead of `.animate.rotate(...)`.\nThe `.animate.rotate(...)` syntax only applies a transformation\nfrom the initial state to the final rotated state\n(interpolation between the two states), without showing proper rotational motion\nbased on the angle (from 0 to the given angle).\nExamples\nExample: RotateMethodExample [¶](#rotatemethodexample)\n![../_images/RotateMethodExample-2.png](../_images/RotateMethodExample-2.png)\n```\nfrom manim import *\nclass RotateMethodExample(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        line = Line(start=ORIGIN, end=RIGHT)\n        arrow1 = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)\n        group1 = VGroup(circle, line, arrow1)\n        group2 = group1.copy()\n        arrow2 = group2[2]\n        arrow2.rotate(angle=PI / 4, about_point=arrow2.get_start())\n        group3 = group1.copy()\n        arrow3 = group3[2]\n        arrow3.rotate(angle=120 * DEGREES, about_point=arrow3.get_start())\n        self.add(VGroup(group1, group2, group3).arrange(RIGHT, buff=1))\n```\n```\nclass RotateMethodExample(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        line = Line(start=ORIGIN, end=RIGHT)\n        arrow1 = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)\n        group1 = VGroup(circle, line, arrow1)\n        group2 = group1.copy()\n        arrow2 = group2[2]\n        arrow2.rotate(angle=PI / 4, about_point=arrow2.get_start())\n        group3 = group1.copy()\n        arrow3 = group3[2]\n        arrow3.rotate(angle=120 * DEGREES, about_point=arrow3.get_start())\n        self.add(VGroup(group1, group2, group3).arrange(RIGHT, buff=1))\n```\nSee also\n[`Rotating`](manim.animation.rotation.Rotating.html#manim.animation.rotation.Rotating \"manim.animation.rotation.Rotating\"), [`Rotate`](manim.animation.rotation.Rotate.html#manim.animation.rotation.Rotate \"manim.animation.rotation.Rotate\"), [`animate`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject.animate \"manim.mobject.mobject.Mobject.animate\"), `apply_points_function_about_point()`\nrotate\\_sheen\\_direction(*angle*, *axis\\=array(\\[0\\., 0\\., 1\\.])*, *family\\=True*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.rotate_sheen_direction)[¶](#manim.mobject.types.vectorized_mobject.VMobject.rotate_sheen_direction \"Link to this definition\")\nRotates the direction of the applied sheen.\nParameters:\n* **angle** (*float*) – Angle by which the direction of sheen is rotated.\n* **axis** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")) – Axis of rotation.\n* **family** (*bool*)\nReturn type:\nSelf\nExamples\nNormal usage:\n```\nCircle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n```\nSee also\n[`set_sheen_direction()`](#manim.mobject.types.vectorized_mobject.VMobject.set_sheen_direction \"manim.mobject.types.vectorized_mobject.VMobject.set_sheen_direction\")\nscale(*scale\\_factor*, *scale\\_stroke\\=False*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.scale)[¶](#manim.mobject.types.vectorized_mobject.VMobject.scale \"Link to this definition\")\nScale the size by a factor.\nDefault behavior is to scale about the center of the vmobject.\nParameters:\n* **scale\\_factor** (*float*) – The scaling factor \\\\(\\\\alpha\\\\). If \\\\(0 \\< \\|\\\\alpha\\| \\< 1\\\\), the mobject\nwill shrink, and for \\\\(\\|\\\\alpha\\| \\> 1\\\\) it will grow. Furthermore,\nif \\\\(\\\\alpha \\< 0\\\\), the mobject is also flipped.\n* **scale\\_stroke** (*bool*) – Boolean determining if the object’s outline is scaled when the object is scaled.\nIf enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\n* **kwargs** – Additional keyword arguments passed to\n[`scale()`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject.scale \"manim.mobject.mobject.Mobject.scale\").\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nExamples\nExample: MobjectScaleExample [¶](#mobjectscaleexample)\n![../_images/MobjectScaleExample-3.png](../_images/MobjectScaleExample-3.png)\n```\nfrom manim import *\nclass MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n        self.add(vg)\n        self.play(\n            c1.animate.scale(.25),\n            c2.animate.scale(.25,\n                scale_stroke=True)\n        )\n```\n```\nclass MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n        self.add(vg)\n        self.play(\n            c1.animate.scale(.25),\n            c2.animate.scale(.25,\n                scale_stroke=True)\n        )\n```\nSee also\n`move_to()`\nscale\\_handle\\_to\\_anchor\\_distances(*factor*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.scale_handle_to_anchor_distances)[¶](#manim.mobject.types.vectorized_mobject.VMobject.scale_handle_to_anchor_distances \"Link to this definition\")\nIf the distance between a given handle point H and its associated\nanchor point A is d, then it changes H to be a distances factor\\*d\naway from A, but so that the line from A to H doesn’t change.\nThis is mostly useful in the context of applying a (differentiable)\nfunction, to preserve tangency properties. One would pull all the\nhandles closer to their anchors, apply the function then push them out\nagain.\nParameters:\n**factor** (*float*) – The factor used for scaling.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nset\\_anchors\\_and\\_handles(*anchors1*, *handles1*, *handles2*, *anchors2*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_anchors_and_handles)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_anchors_and_handles \"Link to this definition\")\nGiven two sets of anchors and handles, process them to set them as anchors\nand handles of the VMobject.\nanchors1\\[i], handles1\\[i], handles2\\[i] and anchors2\\[i] define the i\\-th bezier\ncurve of the vmobject. There are four hardcoded parameters and this is a\nproblem as it makes the number of points per cubic curve unchangeable from 4\n(two anchors and two handles).\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nParameters:\n* **anchors1** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\"))\n* **handles1** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\"))\n* **handles2** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\"))\n* **anchors2** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\"))\nset\\_cap\\_style(*cap\\_style*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_cap_style)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_cap_style \"Link to this definition\")\nSets the cap style of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nParameters:\n**cap\\_style** ([*CapStyleType*](manim.constants.CapStyleType.html#manim.constants.CapStyleType \"manim.constants.CapStyleType\")) – The cap style to be set. See [`CapStyleType`](manim.constants.CapStyleType.html#manim.constants.CapStyleType \"manim.constants.CapStyleType\") for options.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nExamples\nExample: CapStyleExample [¶](#capstyleexample)\n![../_images/CapStyleExample-1.png](../_images/CapStyleExample-1.png)\n```\nfrom manim import *\nclass CapStyleExample(Scene):\n    def construct(self):\n        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n        line.set_cap_style(CapStyleType.ROUND)\n        self.add(line)\n```\n```\nclass CapStyleExample(Scene):\n    def construct(self):\n        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n        line.set_cap_style(CapStyleType.ROUND)\n        self.add(line)\n```\nset\\_color(*color*, *family\\=True*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_color)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_color \"Link to this definition\")\nCondition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color\nParameters:\n* **color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\"))\n* **family** (*bool*)\nReturn type:\nSelf\nset\\_fill(*color\\=None*, *opacity\\=None*, *family\\=True*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_fill)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_fill \"Link to this definition\")\nSet the fill color and fill opacity of a [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nParameters:\n* **color** ([*ParsableManimColor*](manim.utils.color.core.html#manim.utils.color.core.ParsableManimColor \"manim.utils.color.core.ParsableManimColor\") *\\|* *None*) – Fill color of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\n* **opacity** (*float* *\\|* *None*) – Fill opacity of the [`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\n* **family** (*bool*) – If `True`, the fill color of all submobjects is also set.\nReturns:\n`self`\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nExamples\nExample: SetFill [¶](#setfill)\n![../_images/SetFill-1.png](../_images/SetFill-1.png)\n```\nfrom manim import *\nclass SetFill(Scene):\n    def construct(self):\n        square = Square().scale(2).set_fill(WHITE,1)\n        circle1 = Circle().set_fill(GREEN,0.8)\n        circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n        group = Group(circle1,circle2,circle3).arrange()\n        self.add(square)\n        self.add(group)\n```\n```\nclass SetFill(Scene):\n    def construct(self):\n        square = Square().scale(2).set_fill(WHITE,1)\n        circle1 = Circle().set_fill(GREEN,0.8)\n        circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n        group = Group(circle1,circle2,circle3).arrange()\n        self.add(square)\n        self.add(group)\n```\nSee also\n`set_style()`\nset\\_points\\_as\\_corners(*points*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_points_as_corners)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_points_as_corners \"Link to this definition\")\nGiven an array of points, set them as corners of the\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\").\nTo achieve that, this algorithm sets handles aligned with the anchors\nsuch that the resultant Bézier curve will be the segment between the\ntwo anchors.\nParameters:\n**points** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")) – Array of points that will be set as corners.\nReturns:\nThe VMobject itself, after setting the new points as corners.\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")\nExamples\nExample: PointsAsCornersExample [¶](#pointsascornersexample)\n![../_images/PointsAsCornersExample-1.png](../_images/PointsAsCornersExample-1.png)\n```\nfrom manim import *\nclass PointsAsCornersExample(Scene):\n    def construct(self):\n        corners = (\n            # create square\n            UR, UL,\n            DL, DR,\n            UR,\n            # create crosses\n            DL, UL,\n            DR\n        )\n        vmob = VMobject(stroke_color=RED)\n        vmob.set_points_as_corners(corners).scale(2)\n        self.add(vmob)\n```\n```\nclass PointsAsCornersExample(Scene):\n    def construct(self):\n        corners = (\n            # create square\n            UR, UL,\n            DL, DR,\n            UR,\n            # create crosses\n            DL, UL,\n            DR\n        )\n        vmob = VMobject(stroke_color=RED)\n        vmob.set_points_as_corners(corners).scale(2)\n        self.add(vmob)\n```\nset\\_sheen(*factor*, *direction\\=None*, *family\\=True*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_sheen)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_sheen \"Link to this definition\")\nApplies a color gradient from a direction.\nParameters:\n* **factor** (*float*) – The extent of lustre/gradient to apply. If negative, the gradient\nstarts from black, if positive the gradient starts from white and\nchanges to the current color.\n* **direction** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\") *\\|* *None*) – Direction from where the gradient is applied.\n* **family** (*bool*)\nReturn type:\nSelf\nExamples\nExample: SetSheen [¶](#setsheen)\n![../_images/SetSheen-1.png](../_images/SetSheen-1.png)\n```\nfrom manim import *\nclass SetSheen(Scene):\n    def construct(self):\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n        self.add(circle)\n```\n```\nclass SetSheen(Scene):\n    def construct(self):\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n        self.add(circle)\n```\nset\\_sheen\\_direction(*direction*, *family\\=True*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.set_sheen_direction)[¶](#manim.mobject.types.vectorized_mobject.VMobject.set_sheen_direction \"Link to this definition\")\nSets the direction of the applied sheen.\nParameters:\n* **direction** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")) – Direction from where the gradient is applied.\n* **family** (*bool*)\nReturn type:\nSelf\nExamples\nNormal usage:\n```\nCircle().set_sheen_direction(UP)\n```\nSee also\n[`set_sheen()`](#manim.mobject.types.vectorized_mobject.VMobject.set_sheen \"manim.mobject.types.vectorized_mobject.VMobject.set_sheen\"), [`rotate_sheen_direction()`](#manim.mobject.types.vectorized_mobject.VMobject.rotate_sheen_direction \"manim.mobject.types.vectorized_mobject.VMobject.rotate_sheen_direction\")\nstart\\_new\\_path(*point*)[\\[source]](../_modules/manim/mobject/types/vectorized_mobject.html#VMobject.start_new_path)[¶](#manim.mobject.types.vectorized_mobject.VMobject.start_new_path \"Link to this definition\")\nAppend a `point` to the `VMobject.points`, which will be the\nbeginning of a new Bézier curve in the path given by the points. If\nthere’s an unfinished curve at the end of `VMobject.points`,\ncomplete it by appending the last Bézier curve’s start anchor as many\ntimes as needed.\nParameters:\n**point** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – A 3D point to append to `VMobject.points`.\nReturns:\nThe VMobject itself, after appending `point` and starting a new\ncurve.\nReturn type:\n[`VMobject`](#manim.mobject.types.vectorized_mobject.VMobject \"manim.mobject.types.vectorized_mobject.VMobject\")",
  "scraped_at": "2025-06-24T17:59:21.629446",
  "content_length": 69069,
  "domain": "docs.manim.community",
  "word_count": 5072,
  "inspection_status": "approved",
  "filename": "VMobject - Manim Community v0.19.0_20250624_175921.json",
  "saved_at": "2025-06-24T17:59:21.629704",
  "approved_at": "2025-06-25T17:18:58.289710"
}