{
  "doc_id": "42192e3ebe759bffb202eebb784b4bba",
  "url": "https://docs.manim.community/en/latest/reference/manim.utils.bezier.html",
  "title": "bezier - Manim Community v0.19.0",
  "content": "bezier[¶](#module-manim.utils.bezier \"Link to this heading\")\n============================================================\nUtility functions related to Bézier curves.\nFunctions\nbezier(*points: [BezierPointsLike](manim.typing.html#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")*) → Callable\\[\\[float \\| [ColVector](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")], [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\") \\| [Point3D\\_Array](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")][\\[source]](../_modules/manim/utils/bezier.html#bezier)[¶](#manim.utils.bezier.bezier \"Link to this definition\")\nbezier(*points: Sequence\\[[Point3DLike\\_Array](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")]*) → Callable\\[\\[float \\| [ColVector](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")], [Point3D\\_Array](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\nClassic implementation of a Bézier curve.\nParameters:\n**points** – \\\\((d\\+1, 3\\)\\\\)\\-shaped array of \\\\(d\\+1\\\\) control points defining a single Bézier\ncurve of degree \\\\(d\\\\). Alternatively, for vectorization purposes, `points` can\nalso be a \\\\((d\\+1, M, 3\\)\\\\)\\-shaped sequence of \\\\(d\\+1\\\\) arrays of \\\\(M\\\\)\ncontrol points each, which define M Bézier curves instead.\nReturns:\n**bezier\\_func** – Function describing the Bézier curve. The behaviour of this function depends on\nthe shape of `points`:\n> * If `points` was a \\\\((d\\+1, 3\\)\\\\) array representing a single Bézier curve,\n> then `bezier_func` can receive either:\n> \n> \n> \t+ a `float` `t`, in which case it returns a\n> \tsingle \\\\((1, 3\\)\\\\)\\-shaped [`Point3D`](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\") representing the evaluation\n> \tof the Bézier at `t`, or\n> \t+ an \\\\((n, 1\\)\\\\)\\-shaped [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")\n> \tcontaining \\\\(n\\\\) values to evaluate the Bézier curve at, returning instead\n> \tan \\\\((n, 3\\)\\\\)\\-shaped [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") containing the points\n> \tresulting from evaluating the Bézier at each of the \\\\(n\\\\) values.\n> Warning\n> \n> \n> If passing a vector of \\\\(t\\\\)\\-values to `bezier_func`, it **must**\n> be a column vector/matrix of shape \\\\((n, 1\\)\\\\). Passing an 1D array of\n> shape \\\\((n,)\\\\) is not supported and **will result in undefined behaviour**.\n> * If `points` was a \\\\((d\\+1, M, 3\\)\\\\) array describing \\\\(M\\\\) Bézier curves,\n> then `bezier_func` can receive either:\n> \n> \n> \t+ a `float` `t`, in which case it returns an\n> \t\\\\((M, 3\\)\\\\)\\-shaped [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") representing the evaluation\n> \tof the \\\\(M\\\\) Bézier curves at the same value `t`, or\n> \t+ an \\\\((M, 1\\)\\\\)\\-shaped\n> \t[`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\") containing \\\\(M\\\\) values, such that the \\\\(i\\\\)\\-th\n> \tBézier curve defined by `points` is evaluated at the corresponding \\\\(i\\\\)\\-th\n> \tvalue in `t`, returning again an \\\\((M, 3\\)\\\\)\\-shaped [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n> \tcontaining those \\\\(M\\\\) evaluations.\n> Warning\n> \n> \n> Unlike the previous case, if you pass a [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\") to `bezier_func`,\n> it **must** contain exactly \\\\(M\\\\) values, each value for each of the \\\\(M\\\\)\n> Bézier curves defined by `points`. Any array of shape other than \\\\((M, 1\\)\\\\)\n> **will result in undefined behaviour**.\nReturn type:\n`typing.Callable` \\[\\[`float` \\| [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")], [`Point3D`](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\") \\| [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\nbezier\\_remap(*bezier\\_tuples*, *new\\_number\\_of\\_curves*)[\\[source]](../_modules/manim/utils/bezier.html#bezier_remap)[¶](#manim.utils.bezier.bezier_remap \"Link to this definition\")\nSubdivides each curve in `bezier_tuples` into as many parts as necessary, until the final number of\ncurves reaches a desired amount, `new_number_of_curves`.\nParameters:\n* **bezier\\_tuples** ([*BezierPointsLike\\_Array*](manim.typing.html#manim.typing.BezierPointsLike_Array \"manim.typing.BezierPointsLike_Array\")) – An array of multiple Bézier curves of degree \\\\(d\\\\) to be remapped. The shape of this array\nmust be `(current_number_of_curves, nppc, dim)`, where:\n\t+ `current_number_of_curves` is the current amount of curves in the array `bezier_tuples`,\n\t+ `nppc` is the amount of points per curve, such that their degree is `nppc-1`, and\n\t+ `dim` is the dimension of the points, usually \\\\(3\\\\).\n* **new\\_number\\_of\\_curves** (*int*) – The number of curves that the output will contain. This needs to be higher than the current number.\nReturns:\nThe new array of shape `(new_number_of_curves, nppc, dim)`,\ncontaining the new Bézier curves after the remap.\nReturn type:\n[`BezierPoints_Array`](manim.typing.html#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\")\nget\\_quadratic\\_approximation\\_of\\_cubic(*a0: [Point3DLike](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")*, *h0: [Point3DLike](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")*, *h1: [Point3DLike](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")*, *a1: [Point3DLike](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")*) → [QuadraticSpline](manim.typing.html#manim.typing.QuadraticSpline \"manim.typing.QuadraticSpline\")[\\[source]](../_modules/manim/utils/bezier.html#get_quadratic_approximation_of_cubic)[¶](#manim.utils.bezier.get_quadratic_approximation_of_cubic \"Link to this definition\")\nget\\_quadratic\\_approximation\\_of\\_cubic(*a0: [Point3DLike\\_Array](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")*, *h0: [Point3DLike\\_Array](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")*, *h1: [Point3DLike\\_Array](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")*, *a1: [Point3DLike\\_Array](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")*) → [QuadraticBezierPath](manim.typing.html#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\")\nIf `a0`, `h0`, `h1` and `a1` are the control points of a cubic\nBézier curve, approximate the curve with two quadratic Bézier curves and\nreturn an array of 6 points, where the first 3 points represent the first\nquadratic curve and the last 3 represent the second one.\nOtherwise, if `a0`, `h0`, `h1` and `a1` are \\_arrays\\_ of \\\\(N\\\\)\npoints representing \\\\(N\\\\) cubic Bézier curves, return an array of\n\\\\(6N\\\\) points where each group of \\\\(6\\\\) consecutive points\napproximates each of the \\\\(N\\\\) curves in a similar way as above.\nNote\nIf the cubic spline given by the original cubic Bézier curves is\nsmooth, this algorithm will generate a quadratic spline which is also\nsmooth.\nIf a cubic Bézier is given by\n\\\\\\[C(t) \\= (1\\-t)^3 A\\_0 \\+ 3(1\\-t)^2 t H\\_0 \\+ 3(1\\-t)t^2 H\\_1 \\+ t^3 A\\_1\\\\]\nwhere \\\\(A\\_0\\\\), \\\\(H\\_0\\\\), \\\\(H\\_1\\\\) and \\\\(A\\_1\\\\) are its\ncontrol points, then this algorithm should generate two quadratic\nBéziers given by\n\\\\\\[\\\\begin{split}Q\\_0(t) \\&\\= (1\\-t)^2 A\\_0 \\+ 2(1\\-t)t M\\_0 \\+ t^2 K \\\\\\\\\nQ\\_1(t) \\&\\= (1\\-t)^2 K \\+ 2(1\\-t)t M\\_1 \\+ t^2 A\\_1\\\\end{split}\\\\]\nwhere \\\\(M\\_0\\\\) and \\\\(M\\_1\\\\) are the respective handles to be\nfound for both curves, and \\\\(K\\\\) is the end anchor of the 1st curve\nand the start anchor of the 2nd, which must also be found.\nTo solve for \\\\(M\\_0\\\\), \\\\(M\\_1\\\\) and \\\\(K\\\\), three conditions\ncan be imposed:\n1. \\\\(Q\\_0'(0\\) \\= \\\\frac{1}{2}C'(0\\)\\\\). The derivative of the first\nquadratic curve at \\\\(t \\= 0\\\\) should be proportional to that of\nthe original cubic curve, also at \\\\(t \\= 0\\\\). Because the cubic\ncurve is split into two parts, it is necessary to divide this by\ntwo: the speed of a point travelling through the curve should be\nhalf of the original. This gives:\n\\\\\\[\\\\begin{split}Q\\_0'(0\\) \\&\\= \\\\frac{1}{2}C'(0\\) \\\\\\\\\n2(M\\_0 \\- A\\_0\\) \\&\\= \\\\frac{3}{2}(H\\_0 \\- A\\_0\\) \\\\\\\\\n2M\\_0 \\- 2A\\_0 \\&\\= \\\\frac{3}{2}H\\_0 \\- \\\\frac{3}{2}A\\_0 \\\\\\\\\n2M\\_0 \\&\\= \\\\frac{3}{2}H\\_0 \\+ \\\\frac{1}{2}A\\_0 \\\\\\\\\nM\\_0 \\&\\= \\\\frac{1}{4}(3H\\_0 \\+ A\\_0\\)\\\\end{split}\\\\]\n2. \\\\(Q\\_1'(1\\) \\= \\\\frac{1}{2}C'(1\\)\\\\). The derivative of the second\nquadratic curve at \\\\(t \\= 1\\\\) should be half of that of the\noriginal cubic curve for the same reasons as above, also at\n\\\\(t \\= 1\\\\). This gives:\n\\\\\\[\\\\begin{split}Q\\_1'(1\\) \\&\\= \\\\frac{1}{2}C'(1\\) \\\\\\\\\n2(A\\_1 \\- M\\_1\\) \\&\\= \\\\frac{3}{2}(A\\_1 \\- H\\_1\\) \\\\\\\\\n2A\\_1 \\- 2M\\_1 \\&\\= \\\\frac{3}{2}A\\_1 \\- \\\\frac{3}{2}H\\_1 \\\\\\\\\n\\-2M\\_1 \\&\\= \\-\\\\frac{1}{2}A\\_1 \\- \\\\frac{3}{2}H\\_1 \\\\\\\\\nM\\_1 \\&\\= \\\\frac{1}{4}(3H\\_1 \\+ A\\_1\\)\\\\end{split}\\\\]\n3. \\\\(Q\\_0'(1\\) \\= Q\\_1'(0\\)\\\\). The derivatives of both quadratic curves\nshould match at the point \\\\(K\\\\), in order for the final spline\nto be smooth. This gives:\n\\\\\\[\\\\begin{split}Q\\_0'(1\\) \\&\\= Q\\_1'(0\\) \\\\\\\\\n2(K \\- M\\_0\\) \\&\\= 2(M\\_1 \\- K) \\\\\\\\\n2K \\- 2M\\_0 \\&\\= 2M\\_1 \\- 2K \\\\\\\\\n4K \\&\\= 2M\\_0 \\+ 2M\\_1 \\\\\\\\\nK \\&\\= \\\\frac{1}{2}(M\\_0 \\+ M\\_1\\)\\\\end{split}\\\\]\nThis is sufficient to find proper control points for the quadratic\nBézier curves.\nParameters:\n* **a0** – The start anchor of a single cubic Bézier curve, or an array of\n\\\\(N\\\\) start anchors for \\\\(N\\\\) curves.\n* **h0** – The first handle of a single cubic Bézier curve, or an array of\n\\\\(N\\\\) first handles for \\\\(N\\\\) curves.\n* **h1** – The second handle of a single cubic Bézier curve, or an array of\n\\\\(N\\\\) second handles for \\\\(N\\\\) curves.\n* **a1** – The end anchor of a single cubic Bézier curve, or an array of\n\\\\(N\\\\) end anchors for \\\\(N\\\\) curves.\nReturns:\nAn array containing either 6 points for 2 quadratic Bézier curves\napproximating the original cubic curve, or \\\\(6N\\\\) points for\n\\\\(2N\\\\) quadratic curves approximating \\\\(N\\\\) cubic curves.\nReturn type:\nresult\nRaises:\n**ValueError** – If `a0`, `h0`, `h1` and `a1` have different dimensions, or\n if their number of dimensions is not 1 or 2\\.\nget\\_smooth\\_closed\\_cubic\\_bezier\\_handle\\_points(*anchors*)[\\[source]](../_modules/manim/utils/bezier.html#get_smooth_closed_cubic_bezier_handle_points)[¶](#manim.utils.bezier.get_smooth_closed_cubic_bezier_handle_points \"Link to this definition\")\nSpecial case of [`get_smooth_cubic_bezier_handle_points()`](#manim.utils.bezier.get_smooth_cubic_bezier_handle_points \"manim.utils.bezier.get_smooth_cubic_bezier_handle_points\"),\nwhen the `anchors` form a closed loop.\nNote\nA system of equations must be solved to get the first handles of\nevery Bézier curve (referred to as \\\\(H\\_1\\\\)).\nThen \\\\(H\\_2\\\\) (the second handles) can be obtained separately.\nSee also\nThe equations were obtained from:\n* [Conditions on control points for continuous curvature. (2016\\). Jaco Stuifbergen.](http://www.jacos.nl/jacos_html/spline/theory/theory_2.html)\nIn general, if there are \\\\(N\\+1\\\\) anchors, there will be \\\\(N\\\\) Bézier curves\nand thus \\\\(N\\\\) pairs of handles to find. We must solve the following\nsystem of equations for the 1st handles (example for \\\\(N \\= 5\\\\)):\n\\\\\\[\\\\begin{split}\\\\begin{pmatrix}\n 4 \\& 1 \\& 0 \\& 0 \\& 1 \\\\\\\\\n 1 \\& 4 \\& 1 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 1 \\& 4 \\& 1 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 1 \\& 4 \\& 1 \\\\\\\\\n 1 \\& 0 \\& 0 \\& 1 \\& 4\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n H\\_{1,0} \\\\\\\\\n H\\_{1,1} \\\\\\\\\n H\\_{1,2} \\\\\\\\\n H\\_{1,3} \\\\\\\\\n H\\_{1,4}\n\\\\end{pmatrix}\n\\=\n\\\\begin{pmatrix}\n 4A\\_0 \\+ 2A\\_1 \\\\\\\\\n 4A\\_1 \\+ 2A\\_2 \\\\\\\\\n 4A\\_2 \\+ 2A\\_3 \\\\\\\\\n 4A\\_3 \\+ 2A\\_4 \\\\\\\\\n 4A\\_4 \\+ 2A\\_5\n\\\\end{pmatrix}\\\\end{split}\\\\]\nwhich will be expressed as \\\\(RH\\_1 \\= D\\\\).\n\\\\(R\\\\) is almost a tridiagonal matrix, so we could use Thomas’ algorithm.\nSee also\n[Tridiagonal matrix algorithm. Wikipedia.](https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm)\nHowever, \\\\(R\\\\) has ones at the opposite corners. A solution to this is\nthe first decomposition proposed in the link below, with \\\\(\\\\alpha \\= 1\\\\):\nSee also\n[Tridiagonal matrix algorithm \\# Variants. Wikipedia.](https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm#Variants)\n\\\\\\[\\\\begin{split}R\n\\=\n\\\\begin{pmatrix}\n 4 \\& 1 \\& 0 \\& 0 \\& 1 \\\\\\\\\n 1 \\& 4 \\& 1 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 1 \\& 4 \\& 1 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 1 \\& 4 \\& 1 \\\\\\\\\n 1 \\& 0 \\& 0 \\& 1 \\& 4\n\\\\end{pmatrix}\n\\&\\=\n\\\\begin{pmatrix}\n 3 \\& 1 \\& 0 \\& 0 \\& 0 \\\\\\\\\n 1 \\& 4 \\& 1 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 1 \\& 4 \\& 1 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 1 \\& 4 \\& 1 \\\\\\\\\n 0 \\& 0 \\& 0 \\& 1 \\& 3\n\\\\end{pmatrix}\n\\+\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\& 0 \\& 1 \\\\\\\\\n 0 \\& 0 \\& 0 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 0 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 0 \\& 0 \\& 0 \\\\\\\\\n 1 \\& 0 \\& 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\n\\&\\=\n\\\\begin{pmatrix}\n 3 \\& 1 \\& 0 \\& 0 \\& 0 \\\\\\\\\n 1 \\& 4 \\& 1 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 1 \\& 4 \\& 1 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 1 \\& 4 \\& 1 \\\\\\\\\n 0 \\& 0 \\& 0 \\& 1 \\& 3\n\\\\end{pmatrix}\n\\+\n\\\\begin{pmatrix}\n 1 \\\\\\\\\n 0 \\\\\\\\\n 0 \\\\\\\\\n 0 \\\\\\\\\n 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\n\\&\\=\nT \\+ uv^t\\\\end{split}\\\\]\nWe decompose \\\\(R \\= T \\+ uv^t\\\\), where \\\\(T\\\\) is a tridiagonal matrix, and\n\\\\(u, v\\\\) are \\\\(N\\\\)\\-D vectors such that \\\\(u\\_0 \\= u\\_{N\\-1} \\= v\\_0 \\= v\\_{N\\-1} \\= 1\\\\),\nand \\\\(u\\_i \\= v\\_i \\= 0, \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\}\\\\).\nThus:\n\\\\\\[\\\\begin{split}RH\\_1 \\&\\= D \\\\\\\\\n\\\\Rightarrow (T \\+ uv^t)H\\_1 \\&\\= D\\\\end{split}\\\\]\nIf we find a vector \\\\(q\\\\) such that \\\\(Tq \\= u\\\\):\n\\\\\\[\\\\begin{split}\\\\Rightarrow (T \\+ Tqv^t)H\\_1 \\&\\= D \\\\\\\\\n\\\\Rightarrow T(I \\+ qv^t)H\\_1 \\&\\= D \\\\\\\\\n\\\\Rightarrow H\\_1 \\&\\= (I \\+ qv^t)^{\\-1} T^{\\-1} D\\\\end{split}\\\\]\nAccording to Sherman\\-Morrison’s formula:\nSee also\n[Sherman\\-Morrison’s formula. Wikipedia.](https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula)\n\\\\\\[(I \\+ qv^t)^{\\-1} \\= I \\- \\\\frac{1}{1 \\+ v^tq} qv^t\\\\]\nIf we find \\\\(Y \\= T^{\\-1} D\\\\), or in other words, if we solve for\n\\\\(Y\\\\) in \\\\(TY \\= D\\\\):\n\\\\\\[\\\\begin{split}H\\_1 \\&\\= (I \\+ qv^t)^{\\-1} T^{\\-1} D \\\\\\\\\n\\&\\= (I \\+ qv^t)^{\\-1} Y \\\\\\\\\n\\&\\= (I \\- \\\\frac{1}{1 \\+ v^tq} qv^t) Y \\\\\\\\\n\\&\\= Y \\- \\\\frac{1}{1 \\+ v^tq} qv^tY\\\\end{split}\\\\]\nTherefore, we must solve for \\\\(q\\\\) and \\\\(Y\\\\) in \\\\(Tq \\= u\\\\) and \\\\(TY \\= D\\\\).\nAs \\\\(T\\\\) is now tridiagonal, we shall use Thomas’ algorithm.\nDefine:\n* \\\\(a \\= \\[a\\_0, \\\\ a\\_1, \\\\ ..., \\\\ a\\_{N\\-2}]\\\\) as \\\\(T\\\\)’s lower diagonal of \\\\(N\\-1\\\\) elements,\nsuch that \\\\(a\\_0 \\= a\\_1 \\= ... \\= a\\_{N\\-2} \\= 1\\\\), so this diagonal is filled with ones;\n* \\\\(b \\= \\[b\\_0, \\\\ b\\_1, \\\\ ..., \\\\ b\\_{N\\-2}, \\\\ b\\_{N\\-1}]\\\\) as \\\\(T\\\\)’s main diagonal of \\\\(N\\\\) elements,\nsuch that \\\\(b\\_0 \\= b\\_{N\\-1} \\= 3\\\\), and \\\\(b\\_1 \\= b\\_2 \\= ... \\= b\\_{N\\-2} \\= 4\\\\);\n* \\\\(c \\= \\[c\\_0, \\\\ c\\_1, \\\\ ..., \\\\ c\\_{N\\-2}]\\\\) as \\\\(T\\\\)’s upper diagonal of \\\\(N\\-1\\\\) elements,\nsuch that \\\\(c\\_0 \\= c\\_1 \\= ... \\= c\\_{N\\-2} \\= 1\\\\): this diagonal is also filled with ones.\nIf, according to Thomas’ algorithm, we define:\n\\\\\\[\\\\begin{split}c'\\_0 \\&\\= \\\\frac{c\\_0}{b\\_0} \\& \\\\\\\\\nc'\\_i \\&\\= \\\\frac{c\\_i}{b\\_i \\- a\\_{i\\-1} c'\\_{i\\-1}}, \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\n\\& \\& \\\\\\\\\nu'\\_0 \\&\\= \\\\frac{u\\_0}{b\\_0} \\& \\\\\\\\\nu'\\_i \\&\\= \\\\frac{u\\_i \\- a\\_{i\\-1} u'\\_{i\\-1}}{b\\_i \\- a\\_{i\\-1} c'\\_{i\\-1}}, \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-1\\\\} \\\\\\\\\n\\& \\& \\\\\\\\\nD'\\_0 \\&\\= \\\\frac{1}{b\\_0} D\\_0 \\& \\\\\\\\\nD'\\_i \\&\\= \\\\frac{1}{b\\_i \\- a\\_{i\\-1} c'\\_{i\\-1}} (D\\_i \\- a\\_{i\\-1} D'\\_{i\\-1}), \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-1\\\\}\\\\end{split}\\\\]\nThen:\n\\\\\\[\\\\begin{split}c'\\_0 \\&\\= \\\\frac{1}{3} \\& \\\\\\\\\nc'\\_i \\&\\= \\\\frac{1}{4 \\- c'\\_{i\\-1}}, \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\n\\& \\& \\\\\\\\\nu'\\_0 \\&\\= \\\\frac{1}{3} \\& \\\\\\\\\nu'\\_i \\&\\= \\\\frac{\\-u'\\_{i\\-1}}{4 \\- c'\\_{i\\-1}} \\= \\-c'\\_i u'\\_{i\\-1}, \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\nu'\\_{N\\-1} \\&\\= \\\\frac{1 \\- u'\\_{N\\-2}}{3 \\- c'\\_{N\\-2}} \\& \\\\\\\\\n\\& \\& \\\\\\\\\nD'\\_0 \\&\\= \\\\frac{1}{3} (4A\\_0 \\+ 2A\\_1\\) \\& \\\\\\\\\nD'\\_i \\&\\= \\\\frac{1}{4 \\- c'\\_{i\\-1}} (4A\\_i \\+ 2A\\_{i\\+1} \\- D'\\_{i\\-1}) \\& \\\\\\\\\n\\&\\= c\\_i (4A\\_i \\+ 2A\\_{i\\+1} \\- D'\\_{i\\-1}), \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\nD'\\_{N\\-1} \\&\\= \\\\frac{1}{3 \\- c'\\_{N\\-2}} (4A\\_{N\\-1} \\+ 2A\\_N \\- D'\\_{N\\-2}) \\&\\\\end{split}\\\\]\nFinally, we can do Backward Substitution to find \\\\(q\\\\) and \\\\(Y\\\\):\n\\\\\\[\\\\begin{split}q\\_{N\\-1} \\&\\= u'\\_{N\\-1} \\& \\\\\\\\\nq\\_i \\&\\= u'\\_{i} \\- c'\\_i q\\_{i\\+1}, \\& \\\\quad \\\\forall i \\\\in \\\\{0, ..., N\\-2\\\\} \\\\\\\\\n\\& \\& \\\\\\\\\nY\\_{N\\-1} \\&\\= D'\\_{N\\-1} \\& \\\\\\\\\nY\\_i \\&\\= D'\\_i \\- c'\\_i Y\\_{i\\+1}, \\& \\\\quad \\\\forall i \\\\in \\\\{0, ..., N\\-2\\\\}\\\\end{split}\\\\]\nWith those values, we can finally calculate \\\\(H\\_1 \\= Y \\- \\\\frac{1}{1 \\+ v^tq} qv^tY\\\\).\nGiven that \\\\(v\\_0 \\= v\\_{N\\-1} \\= 1\\\\), and \\\\(v\\_1 \\= v\\_2 \\= ... \\= v\\_{N\\-2} \\= 0\\\\), its dot products\nwith \\\\(q\\\\) and \\\\(Y\\\\) are respectively \\\\(v^tq \\= q\\_0 \\+ q\\_{N\\-1}\\\\) and\n\\\\(v^tY \\= Y\\_0 \\+ Y\\_{N\\-1}\\\\). Thus:\n\\\\\\[H\\_1 \\= Y \\- \\\\frac{1}{1 \\+ q\\_0 \\+ q\\_{N\\-1}} q(Y\\_0 \\+ Y\\_{N\\-1})\\\\]\nOnce we have \\\\(H\\_1\\\\), we can get \\\\(H\\_2\\\\) (the array of second handles) as follows:\n\\\\\\[\\\\begin{split}H\\_{2, i} \\&\\= 2A\\_{i\\+1} \\- H\\_{1, i\\+1}, \\& \\\\quad \\\\forall i \\\\in \\\\{0, ..., N\\-2\\\\} \\\\\\\\\nH\\_{2, N\\-1} \\&\\= 2A\\_0 \\- H\\_{1, 0} \\&\\\\end{split}\\\\]\nBecause the matrix \\\\(R\\\\) always follows the same pattern (and thus \\\\(T, u, v\\\\) as well),\nwe can define a memo list for \\\\(c'\\\\) and \\\\(u'\\\\) to avoid recalculation. We cannot\nmemoize \\\\(D\\\\) and \\\\(Y\\\\), however, because they are always different matrices. We\ncannot make a memo for \\\\(q\\\\) either, but we can calculate it faster because \\\\(u'\\\\)\ncan be memoized.\nParameters:\n**anchors** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")) – Anchors of a closed cubic spline.\nReturns:\nA tuple of two arrays: one containing the 1st handle for every curve in\nthe closed cubic spline, and the other containing the 2nd handles.\nReturn type:\n`tuple` \\[[`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\"), [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\nget\\_smooth\\_cubic\\_bezier\\_handle\\_points(*anchors*)[\\[source]](../_modules/manim/utils/bezier.html#get_smooth_cubic_bezier_handle_points)[¶](#manim.utils.bezier.get_smooth_cubic_bezier_handle_points \"Link to this definition\")\nGiven an array of anchors for a cubic spline (array of connected cubic\nBézier curves), compute the 1st and 2nd handle for every curve, so that\nthe resulting spline is smooth.\nParameters:\n**anchors** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")) – Anchors of a cubic spline.\nReturns:\nA tuple of two arrays: one containing the 1st handle for every curve in\nthe cubic spline, and the other containing the 2nd handles.\nReturn type:\n`tuple` \\[[`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\"), [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\nget\\_smooth\\_open\\_cubic\\_bezier\\_handle\\_points(*anchors*)[\\[source]](../_modules/manim/utils/bezier.html#get_smooth_open_cubic_bezier_handle_points)[¶](#manim.utils.bezier.get_smooth_open_cubic_bezier_handle_points \"Link to this definition\")\nSpecial case of [`get_smooth_cubic_bezier_handle_points()`](#manim.utils.bezier.get_smooth_cubic_bezier_handle_points \"manim.utils.bezier.get_smooth_cubic_bezier_handle_points\"),\nwhen the `anchors` do not form a closed loop.\nNote\nA system of equations must be solved to get the first handles of\nevery Bèzier curve (referred to as \\\\(H\\_1\\\\)).\nThen \\\\(H\\_2\\\\) (the second handles) can be obtained separately.\nSee also\nThe equations were obtained from:\n* [Smooth Bézier Spline Through Prescribed Points. (2012\\). Particle in Cell Consulting LLC.](https://www.particleincell.com/2012/bezier-splines/)\n* [Conditions on control points for continuous curvature. (2016\\). Jaco Stuifbergen.](http://www.jacos.nl/jacos_html/spline/theory/theory_2.html)\nWarning\nThe equations in the first webpage have some typos which were corrected in the comments.\nIn general, if there are \\\\(N\\+1\\\\) anchors, there will be \\\\(N\\\\) Bézier curves\nand thus \\\\(N\\\\) pairs of handles to find. We must solve the following\nsystem of equations for the 1st handles (example for \\\\(N \\= 5\\\\)):\n\\\\\\[\\\\begin{split}\\\\begin{pmatrix}\n 2 \\& 1 \\& 0 \\& 0 \\& 0 \\\\\\\\\n 1 \\& 4 \\& 1 \\& 0 \\& 0 \\\\\\\\\n 0 \\& 1 \\& 4 \\& 1 \\& 0 \\\\\\\\\n 0 \\& 0 \\& 1 \\& 4 \\& 1 \\\\\\\\\n 0 \\& 0 \\& 0 \\& 2 \\& 7\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n H\\_{1,0} \\\\\\\\\n H\\_{1,1} \\\\\\\\\n H\\_{1,2} \\\\\\\\\n H\\_{1,3} \\\\\\\\\n H\\_{1,4}\n\\\\end{pmatrix}\n\\=\n\\\\begin{pmatrix}\n A\\_0 \\+ 2A\\_1 \\\\\\\\\n 4A\\_1 \\+ 2A\\_2 \\\\\\\\\n 4A\\_2 \\+ 2A\\_3 \\\\\\\\\n 4A\\_3 \\+ 2A\\_4 \\\\\\\\\n 8A\\_4 \\+ A\\_5\n\\\\end{pmatrix}\\\\end{split}\\\\]\nwhich will be expressed as \\\\(TH\\_1 \\= D\\\\).\n\\\\(T\\\\) is a tridiagonal matrix, so the system can be solved in \\\\(O(N)\\\\)\noperations. Here we shall use Thomas’ algorithm or the tridiagonal matrix\nalgorithm.\nSee also\n[Tridiagonal matrix algorithm. Wikipedia.](https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm)\nDefine:\n* \\\\(a \\= \\[a\\_0, \\\\ a\\_1, \\\\ ..., \\\\ a\\_{N\\-2}]\\\\) as \\\\(T\\\\)’s lower diagonal of \\\\(N\\-1\\\\) elements,\nsuch that \\\\(a\\_0 \\= a\\_1 \\= ... \\= a\\_{N\\-3} \\= 1\\\\), and \\\\(a\\_{N\\-2} \\= 2\\\\);\n* \\\\(b \\= \\[b\\_0, \\\\ b\\_1, \\\\ ..., \\\\ b\\_{N\\-2}, \\\\ b\\_{N\\-1}]\\\\) as \\\\(T\\\\)’s main diagonal of \\\\(N\\\\) elements,\nsuch that \\\\(b\\_0 \\= 2\\\\), \\\\(b\\_1 \\= b\\_2 \\= ... \\= b\\_{N\\-2} \\= 4\\\\), and \\\\(b\\_{N\\-1} \\= 7\\\\);\n* \\\\(c \\= \\[c\\_0, \\\\ c\\_1, \\\\ ..., \\\\ c\\_{N\\-2}]\\\\) as \\\\(T\\\\)’s upper diagonal of \\\\({N\\-1}\\\\) elements,\nsuch that \\\\(c\\_0 \\= c\\_1 \\= ... \\= c\\_{N\\-2} \\= 1\\\\): this diagonal is filled with ones.\nIf, according to Thomas’ algorithm, we define:\n\\\\\\[\\\\begin{split}c'\\_0 \\&\\= \\\\frac{c\\_0}{b\\_0} \\& \\\\\\\\\nc'\\_i \\&\\= \\\\frac{c\\_i}{b\\_i \\- a\\_{i\\-1} c'\\_{i\\-1}}, \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\n\\& \\& \\\\\\\\\nD'\\_0 \\&\\= \\\\frac{1}{b\\_0} D\\_0 \\& \\\\\\\\\nD'\\_i \\&\\= \\\\frac{1}{b\\_i \\- a\\_{i\\-1} c'{i\\-1}} (D\\_i \\- a\\_{i\\-1} D'\\_{i\\-1}), \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-1\\\\}\\\\end{split}\\\\]\nThen:\n\\\\\\[\\\\begin{split}c'\\_0 \\&\\= 0\\.5 \\& \\\\\\\\\nc'\\_i \\&\\= \\\\frac{1}{4 \\- c'\\_{i\\-1}}, \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\n\\& \\& \\\\\\\\\nD'\\_0 \\&\\= 0\\.5A\\_0 \\+ A\\_1 \\& \\\\\\\\\nD'\\_i \\&\\= \\\\frac{1}{4 \\- c'\\_{i\\-1}} (4A\\_i \\+ 2A\\_{i\\+1} \\- D'\\_{i\\-1}) \\& \\\\\\\\\n\\&\\= c\\_i (4A\\_i \\+ 2A\\_{i\\+1} \\- D'\\_{i\\-1}), \\& \\\\quad \\\\forall i \\\\in \\\\{1, ..., N\\-2\\\\} \\\\\\\\\nD'\\_{N\\-1} \\&\\= \\\\frac{1}{7 \\- 2c'\\_{N\\-2}} (8A\\_{N\\-1} \\+ A\\_N \\- 2D'\\_{N\\-2}) \\&\\\\end{split}\\\\]\nFinally, we can do Backward Substitution to find \\\\(H\\_1\\\\):\n\\\\\\[\\\\begin{split}H\\_{1, N\\-1} \\&\\= D'\\_{N\\-1} \\& \\\\\\\\\nH\\_{1, i} \\&\\= D'\\_i \\- c'\\_i H\\_{1, i\\+1}, \\& \\\\quad \\\\forall i \\\\in \\\\{0, ..., N\\-2\\\\}\\\\end{split}\\\\]\nOnce we have \\\\(H\\_1\\\\), we can get \\\\(H\\_2\\\\) (the array of second handles) as follows:\n\\\\\\[\\\\begin{split}H\\_{2, i} \\&\\= 2A\\_{i\\+1} \\- H\\_{1, i\\+1}, \\& \\\\quad \\\\forall i \\\\in \\\\{0, ..., N\\-2\\\\} \\\\\\\\\nH\\_{2, N\\-1} \\&\\= 0\\.5A\\_N \\+ 0\\.5H\\_{1, N\\-1} \\&\\\\end{split}\\\\]\nAs the matrix \\\\(T\\\\) always follows the same pattern, we can define a memo list\nfor \\\\(c'\\\\) to avoid recalculation. We cannot do the same for \\\\(D\\\\), however,\nbecause it is always a different matrix.\nParameters:\n**anchors** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")) – Anchors of an open cubic spline.\nReturns:\nA tuple of two arrays: one containing the 1st handle for every curve in\nthe open cubic spline, and the other containing the 2nd handles.\nReturn type:\n`tuple` \\[[`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\"), [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\ninteger\\_interpolate(*start*, *end*, *alpha*)[\\[source]](../_modules/manim/utils/bezier.html#integer_interpolate)[¶](#manim.utils.bezier.integer_interpolate \"Link to this definition\")\nThis is a variant of interpolate that returns an integer and the residual\nParameters:\n* **start** (*float*) – The start of the range\n* **end** (*float*) – The end of the range\n* **alpha** (*float*) – a float between 0 and 1\\.\nReturns:\nThis returns an integer between start and end (inclusive) representing\nappropriate interpolation between them, along with a\n“residue” representing a new proportion between the\nreturned integer and the next one of the\nlist.\nReturn type:\ntuple\\[int, float]\nExample\n```\n>>> integer, residue = integer_interpolate(start=0, end=10, alpha=0.46)\n>>> np.allclose((integer, residue), (4, 0.6))\nTrue\n```\ninterpolate(*start: float*, *end: float*, *alpha: float*) → float[\\[source]](../_modules/manim/utils/bezier.html#interpolate)[¶](#manim.utils.bezier.interpolate \"Link to this definition\")\ninterpolate(*start: float*, *end: float*, *alpha: [ColVector](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")*) → [ColVector](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")\ninterpolate(*start: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *end: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *alpha: float*) → [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")\ninterpolate(*start: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *end: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *alpha: [ColVector](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\")*) → [Point3D\\_Array](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nLinearly interpolates between two values `start` and `end`.\nParameters:\n* **start** – The start of the range.\n* **end** – The end of the range.\n* **alpha** – A float between 0 and 1, or an \\\\((n, 1\\)\\\\) column vector containing\n\\\\(n\\\\) floats between 0 and 1 to interpolate in a vectorized fashion.\nReturns:\nThe result of the linear interpolation.\n* If `start` and `end` are of type `float`, and:\n\t+ `alpha` is also a `float`, the return is simply another `float`.\n\t+ `alpha` is a [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\"), the return is another [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\").\n* If `start` and `end` are of type [`Point3D`](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\"), and:\n\t+ `alpha` is a `float`, the return is another [`Point3D`](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\").\n\t+ `alpha` is a [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\"), the return is a [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\").\nReturn type:\n`float` \\| [`ColVector`](manim.typing.html#manim.typing.ColVector \"manim.typing.ColVector\") \\| [`Point3D`](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\") \\| [`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\ninverse\\_interpolate(*start: float*, *end: float*, *value: float*) → float[\\[source]](../_modules/manim/utils/bezier.html#inverse_interpolate)[¶](#manim.utils.bezier.inverse_interpolate \"Link to this definition\")\ninverse\\_interpolate(*start: float*, *end: float*, *value: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*) → [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")\ninverse\\_interpolate(*start: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *end: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *value: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*) → [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")\nPerform inverse interpolation to determine the alpha\nvalues that would produce the specified `value`\ngiven the `start` and `end` values or points.\nParameters:\n* **start** – The start value or point of the interpolation.\n* **end** – The end value or point of the interpolation.\n* **value** – The value or point for which the alpha value\nshould be determined.\nReturns:\n* *The alpha values producing the given input*\n* when interpolating between `start` and `end`.\nExample\n```\n>>> inverse_interpolate(start=2, end=6, value=4)\nnp.float64(0.5)\n>>> start = np.array([1, 2, 1])\n>>> end = np.array([7, 8, 11])\n>>> value = np.array([4, 5, 5])\n>>> inverse_interpolate(start, end, value)\narray([0.5, 0.5, 0.4])\n```\nis\\_closed(*points*)[\\[source]](../_modules/manim/utils/bezier.html#is_closed)[¶](#manim.utils.bezier.is_closed \"Link to this definition\")\nReturns `True` if the spline given by `points` is closed, by\nchecking if its first and last points are close to each other, or\\`\\`False\\`\\`\notherwise.\nNote\nThis function reimplements `np.allclose()`, because repeated\ncalling of `np.allclose()` for only 2 points is inefficient.\nParameters:\n**points** ([*Point3D\\_Array*](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")) – An array of points defining a spline.\nReturns:\nWhether the first and last points of the array are close enough or not\nto be considered the same, thus considering the defined spline as\nclosed.\nReturn type:\n`bool`\nExamples\n```\n>>> import numpy as np\n>>> from manim import is_closed\n>>> is_closed(\n...     np.array(\n...         [\n...             [0, 0, 0],\n...             [1, 2, 3],\n...             [3, 2, 1],\n...             [0, 0, 0],\n...         ]\n...     )\n... )\nTrue\n>>> is_closed(\n...     np.array(\n...         [\n...             [0, 0, 0],\n...             [1, 2, 3],\n...             [3, 2, 1],\n...             [1e-10, 1e-10, 1e-10],\n...         ]\n...     )\n... )\nTrue\n>>> is_closed(\n...     np.array(\n...         [\n...             [0, 0, 0],\n...             [1, 2, 3],\n...             [3, 2, 1],\n...             [1e-2, 1e-2, 1e-2],\n...         ]\n...     )\n... )\nFalse\n```\nmatch\\_interpolate(*new\\_start: float*, *new\\_end: float*, *old\\_start: float*, *old\\_end: float*, *old\\_value: float*) → float[\\[source]](../_modules/manim/utils/bezier.html#match_interpolate)[¶](#manim.utils.bezier.match_interpolate \"Link to this definition\")\nmatch\\_interpolate(*new\\_start: float*, *new\\_end: float*, *old\\_start: float*, *old\\_end: float*, *old\\_value: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*) → [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")\nInterpolate a value from an old range to a new range.\nParameters:\n* **new\\_start** – The start of the new range.\n* **new\\_end** – The end of the new range.\n* **old\\_start** – The start of the old range.\n* **old\\_end** – The end of the old range.\n* **old\\_value** – The value within the old range whose corresponding\nvalue in the new range (with the same alpha value)\nis desired.\nReturn type:\nThe interpolated value within the new range.\nExamples\n```\n>>> match_interpolate(0, 100, 10, 20, 15)\nnp.float64(50.0)\n```\nmid(*start: float*, *end: float*) → float[\\[source]](../_modules/manim/utils/bezier.html#mid)[¶](#manim.utils.bezier.mid \"Link to this definition\")\nmid(*start: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*, *end: [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")*) → [Point3D](manim.typing.html#manim.typing.Point3D \"manim.typing.Point3D\")\nReturns the midpoint between two values.\nParameters:\n* **start** – The first value\n* **end** – The second value\nReturn type:\nThe midpoint between the two values\npartial\\_bezier\\_points(*points*, *a*, *b*)[\\[source]](../_modules/manim/utils/bezier.html#partial_bezier_points)[¶](#manim.utils.bezier.partial_bezier_points \"Link to this definition\")\nGiven an array of `points` which define a Bézier curve, and two numbers \\\\(a, b\\\\)\nsuch that \\\\(0 \\\\le a \\< b \\\\le 1\\\\), return an array of the same size, which describes the\nportion of the original Bézier curve on the interval \\\\(\\[a, b]\\\\).\n[`partial_bezier_points()`](#manim.utils.bezier.partial_bezier_points \"manim.utils.bezier.partial_bezier_points\") is conceptually equivalent to calling [`split_bezier()`](#manim.utils.bezier.split_bezier \"manim.utils.bezier.split_bezier\")\ntwice and discarding unused Bézier curves, but this is more efficient and doesn’t waste\ncomputations.\nSee also\nSee [`split_bezier()`](#manim.utils.bezier.split_bezier \"manim.utils.bezier.split_bezier\") for an explanation on how to split Bézier curves.\nNote\nTo find the portion of a Bézier curve with \\\\(t\\\\) between \\\\(a\\\\) and \\\\(b\\\\):\n1. Split the curve at \\\\(t \\= a\\\\) and extract its 2nd subcurve.\n2. We cannot evaluate the new subcurve at \\\\(t \\= b\\\\) because its range of values for \\\\(t\\\\) is different.\nTo find the correct value, we need to transform the interval \\\\(\\[a, 1]\\\\) into \\\\(\\[0, 1]\\\\)\nby first subtracting \\\\(a\\\\) to get \\\\(\\[0, 1\\-a]\\\\) and then dividing by \\\\(1\\-a\\\\). Thus, our new\nvalue must be \\\\(t \\= \\\\frac{b \\- a}{1 \\- a}\\\\). Define \\\\(u \\= \\\\frac{b \\- a}{1 \\- a}\\\\).\n3. Split the subcurve at \\\\(t \\= u\\\\) and extract its 1st subcurve.\nThe final portion is a linear combination of points, and thus the process can be\nsummarized as a linear transformation by some matrix in terms of \\\\(a\\\\) and \\\\(b\\\\).\nThis matrix is given explicitly for Bézier curves up to degree 3, which are often used in Manim.\nFor higher degrees, the algorithm described previously is used.\nFor the case of a quadratic Bézier curve:\n* Step 1:\n\\\\\\[\\\\begin{split}H'\\_1\n\\=\n\\\\begin{pmatrix}\n (1\\-a)^2 \\& 2(1\\-a)a \\& a^2 \\\\\\\\\n 0 \\& (1\\-a) \\& a \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\\\\end{split}\\\\]\n* Step 2:\n\\\\\\[\\\\begin{split}H''\\_0\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n (1\\-u) \\& u \\& 0\\\\\\\\\n (1\\-u)^2 \\& 2(1\\-u)u \\& u^2\n\\\\end{pmatrix}\nH'\\_1\n\\\\\\\\\n\\&\n\\\\\\\\\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n (1\\-u) \\& u \\& 0\\\\\\\\\n (1\\-u)^2 \\& 2(1\\-u)u \\& u^2\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n (1\\-a)^2 \\& 2(1\\-a)a \\& a^2 \\\\\\\\\n 0 \\& (1\\-a) \\& a \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\n\\&\\=\n\\\\begin{pmatrix}\n (1\\-a)^2 \\& 2(1\\-a)a \\& a^2 \\\\\\\\\n (1\\-a)(1\\-b) \\& a(1\\-b) \\+ (1\\-a)b \\& ab \\\\\\\\\n (1\\-b)^2 \\& 2(1\\-b)b \\& b^2\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\\\\end{split}\\\\]\nfrom where one can define a \\\\((3, 3\\)\\\\) matrix \\\\(P\\_2\\\\) which, when applied over\nthe array of `points`, will return the desired partial quadratic Bézier curve:\n\\\\\\[\\\\begin{split}P\\_2\n\\=\n\\\\begin{pmatrix}\n (1\\-a)^2 \\& 2(1\\-a)a \\& a^2 \\\\\\\\\n (1\\-a)(1\\-b) \\& a(1\\-b) \\+ (1\\-a)b \\& ab \\\\\\\\\n (1\\-b)^2 \\& 2(1\\-b)b \\& b^2\n\\\\end{pmatrix}\\\\end{split}\\\\]\nSimilarly, for the cubic Bézier curve case, one can define the following\n\\\\((4, 4\\)\\\\) matrix \\\\(P\\_3\\\\):\n\\\\\\[\\\\begin{split}P\\_3\n\\=\n\\\\begin{pmatrix}\n (1\\-a)^3 \\& 3(1\\-a)^2a \\& 3(1\\-a)a^2 \\& a^3 \\\\\\\\\n (1\\-a)^2(1\\-b) \\& 2(1\\-a)a(1\\-b) \\+ (1\\-a)^2b \\& a^2(1\\-b) \\+ 2(1\\-a)ab \\& a^2b \\\\\\\\\n (1\\-a)(1\\-b)^2 \\& a(1\\-b)^2 \\+ 2(1\\-a)(1\\-b)b \\& 2a(1\\-b)b \\+ (1\\-a)b^2 \\& ab^2 \\\\\\\\\n (1\\-b)^3 \\& 3(1\\-b)^2b \\& 3(1\\-b)b^2 \\& b^3\n\\\\end{pmatrix}\\\\end{split}\\\\]\nParameters:\n* **points** ([*BezierPointsLike*](manim.typing.html#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")) – set of points defining the bezier curve.\n* **a** (*float*) – lower bound of the desired partial bezier curve.\n* **b** (*float*) – upper bound of the desired partial bezier curve.\nReturns:\nAn array containing the control points defining the partial Bézier curve.\nReturn type:\n[`BezierPoints`](manim.typing.html#manim.typing.BezierPoints \"manim.typing.BezierPoints\")\npoint\\_lies\\_on\\_bezier(*point*, *control\\_points*, *round\\_to\\=1e\\-06*)[\\[source]](../_modules/manim/utils/bezier.html#point_lies_on_bezier)[¶](#manim.utils.bezier.point_lies_on_bezier \"Link to this definition\")\nChecks if a given point lies on the bezier curves with the given control points.\nThis is done by solving the bezier polynomial with the point as the constant term; if\nany real roots exist, the point lies on the bezier curve.\nParameters:\n* **point** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – The Cartesian Coordinates of the point to check.\n* **control\\_points** ([*BezierPointsLike*](manim.typing.html#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")) – The Cartesian Coordinates of the ordered control\npoints of the bezier curve on which the point may\nor may not lie.\n* **round\\_to** (*float*) – A float whose number of decimal places all values\nsuch as coordinates of points will be rounded.\nReturns:\nWhether the point lies on the curve.\nReturn type:\nbool\nproportions\\_along\\_bezier\\_curve\\_for\\_point(*point*, *control\\_points*, *round\\_to\\=1e\\-06*)[\\[source]](../_modules/manim/utils/bezier.html#proportions_along_bezier_curve_for_point)[¶](#manim.utils.bezier.proportions_along_bezier_curve_for_point \"Link to this definition\")\nObtains the proportion along the bezier curve corresponding to a given point\ngiven the bezier curve’s control points.\nThe bezier polynomial is constructed using the coordinates of the given point\nas well as the bezier curve’s control points. On solving the polynomial for each dimension,\nif there are roots common to every dimension, those roots give the proportion along the\ncurve the point is at. If there are no real roots, the point does not lie on the curve.\nParameters:\n* **point** ([*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")) – The Cartesian Coordinates of the point whose parameter\nshould be obtained.\n* **control\\_points** ([*BezierPointsLike*](manim.typing.html#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")) – The Cartesian Coordinates of the ordered control\npoints of the bezier curve on which the point may\nor may not lie.\n* **round\\_to** (*float*) – A float whose number of decimal places all values\nsuch as coordinates of points will be rounded.\nReturns:\nList containing possible parameters (the proportions along the bezier curve)\nfor the given point on the given bezier curve.\nThis usually only contains one or zero elements, but if the\npoint is, say, at the beginning/end of a closed loop, may return\na list with more than 1 value, corresponding to the beginning and\nend etc. of the loop.\nReturn type:\nnp.ndarray\\[float]\nRaises:\n**ValueError** – When `point` and the control points have different shapes.\nsplit\\_bezier(*points*, *t*)[\\[source]](../_modules/manim/utils/bezier.html#split_bezier)[¶](#manim.utils.bezier.split_bezier \"Link to this definition\")\nSplit a Bézier curve at argument `t` into two curves.\nNote\nSee also\n[A Primer on Bézier Curves \\#10: Splitting curves. Pomax.](https://pomax.github.io/bezierinfo/#splitting)\nAs an example for a cubic Bézier curve, let \\\\(p\\_0, p\\_1, p\\_2, p\\_3\\\\) be the points\nneeded for the curve \\\\(C\\_0 \\= \\[p\\_0, \\\\ p\\_1, \\\\ p\\_2, \\\\ p\\_3]\\\\).\nDefine the 3 linear Béziers \\\\(L\\_0, L\\_1, L\\_2\\\\) as interpolations of \\\\(p\\_0, p\\_1, p\\_2, p\\_3\\\\):\n\\\\\\[\\\\begin{split}L\\_0(t) \\&\\= p\\_0 \\+ t(p\\_1 \\- p\\_0\\) \\\\\\\\\nL\\_1(t) \\&\\= p\\_1 \\+ t(p\\_2 \\- p\\_1\\) \\\\\\\\\nL\\_2(t) \\&\\= p\\_2 \\+ t(p\\_3 \\- p\\_2\\)\\\\end{split}\\\\]\nDefine the 2 quadratic Béziers \\\\(Q\\_0, Q\\_1\\\\) as interpolations of \\\\(L\\_0, L\\_1, L\\_2\\\\):\n\\\\\\[\\\\begin{split}Q\\_0(t) \\&\\= L\\_0(t) \\+ t(L\\_1(t) \\- L\\_0(t)) \\\\\\\\\nQ\\_1(t) \\&\\= L\\_1(t) \\+ t(L\\_2(t) \\- L\\_1(t))\\\\end{split}\\\\]\nThen \\\\(C\\_0\\\\) is the following interpolation of \\\\(Q\\_0\\\\) and \\\\(Q\\_1\\\\):\n\\\\\\[C\\_0(t) \\= Q\\_0(t) \\+ t(Q\\_1(t) \\- Q\\_0(t))\\\\]\nEvaluating \\\\(C\\_0\\\\) at a value \\\\(t\\=t'\\\\) splits \\\\(C\\_0\\\\) into two cubic Béziers \\\\(H\\_0\\\\)\nand \\\\(H\\_1\\\\), defined by some of the points we calculated earlier:\n\\\\\\[\\\\begin{split}H\\_0 \\&\\= \\[p\\_0, \\&\\\\ L\\_0(t'), \\&\\\\ Q\\_0(t'), \\&\\\\ C\\_0(t') \\&] \\\\\\\\\nH\\_1 \\&\\= \\[p\\_0(t'), \\&\\\\ Q\\_1(t'), \\&\\\\ L\\_2(t'), \\&\\\\ p\\_3 \\&]\\\\end{split}\\\\]\nAs the resulting curves are obtained from linear combinations of `points`, everything can\nbe encoded into a matrix for efficiency, which is done for Bézier curves of degree up to 3\\.\nSee also\n[A Primer on Bézier Curves \\#11: Splitting curves using matrices. Pomax.](https://pomax.github.io/bezierinfo/#matrixsplit)\nFor the simpler case of a quadratic Bézier curve:\n\\\\\\[\\\\begin{split}H\\_0\n\\&\\=\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n (1\\-t) p\\_0 \\+ t p\\_1 \\\\\\\\\n (1\\-t)^2 p\\_0 \\+ 2(1\\-t)t p\\_1 \\+ t^2 p\\_2 \\\\\\\\\n\\\\end{pmatrix}\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n (1\\-t) \\& t \\& 0\\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\nH\\_1\n\\&\\=\n\\\\begin{pmatrix}\n (1\\-t)^2 p\\_0 \\+ 2(1\\-t)t p\\_1 \\+ t^2 p\\_2 \\\\\\\\\n (1\\-t) p\\_1 \\+ t p\\_2 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\n\\&\\=\n\\\\begin{pmatrix}\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n 0 \\& (1\\-t) \\& t \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\\\\end{split}\\\\]\nfrom where one can define a \\\\((6, 3\\)\\\\) split matrix \\\\(S\\_2\\\\) which can multiply\nthe array of `points` to compute the return value:\n\\\\\\[\\\\begin{split}S\\_2\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n (1\\-t) \\& t \\& 0 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n 0 \\& (1\\-t) \\& t \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\nS\\_2 P\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n (1\\-t) \\& t \\& 0 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n 0 \\& (1\\-t) \\& t \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2\n\\\\end{pmatrix}\n\\=\n\\\\begin{pmatrix}\n \\\\vert \\\\\\\\\n H\\_0 \\\\\\\\\n \\\\vert \\\\\\\\\n \\\\vert \\\\\\\\\n H\\_1 \\\\\\\\\n \\\\vert\n\\\\end{pmatrix}\\\\end{split}\\\\]\nFor the previous example with a cubic Bézier curve:\n\\\\\\[\\\\begin{split}H\\_0\n\\&\\=\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n (1\\-t) p\\_0 \\+ t p\\_1 \\\\\\\\\n (1\\-t)^2 p\\_0 \\+ 2(1\\-t)t p\\_1 \\+ t^2 p\\_2 \\\\\\\\\n (1\\-t)^3 p\\_0 \\+ 3(1\\-t)^2 t p\\_1 \\+ 3(1\\-t)t^2 p\\_2 \\+ t^3 p\\_3\n\\\\end{pmatrix}\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\& 0 \\\\\\\\\n (1\\-t) \\& t \\& 0 \\& 0 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\& 0 \\\\\\\\\n (1\\-t)^3 \\& 3(1\\-t)^2 t \\& 3(1\\-t)t^2 \\& t^3\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2 \\\\\\\\\n p\\_3\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\nH\\_1\n\\&\\=\n\\\\begin{pmatrix}\n (1\\-t)^3 p\\_0 \\+ 3(1\\-t)^2 t p\\_1 \\+ 3(1\\-t)t^2 p\\_2 \\+ t^3 p\\_3 \\\\\\\\\n (1\\-t)^2 p\\_1 \\+ 2(1\\-t)t p\\_2 \\+ t^2 p\\_3 \\\\\\\\\n (1\\-t) p\\_2 \\+ t p\\_3 \\\\\\\\\n p\\_3\n\\\\end{pmatrix}\n\\&\\=\n\\\\begin{pmatrix}\n (1\\-t)^3 \\& 3(1\\-t)^2 t \\& 3(1\\-t)t^2 \\& t^3 \\\\\\\\\n 0 \\& (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n 0 \\& 0 \\& (1\\-t) \\& t \\\\\\\\\n 0 \\& 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2 \\\\\\\\\n p\\_3\n\\\\end{pmatrix}\\\\end{split}\\\\]\nfrom where one can define a \\\\((8, 4\\)\\\\) split matrix \\\\(S\\_3\\\\) which can multiply\nthe array of `points` to compute the return value:\n\\\\\\[\\\\begin{split}S\\_3\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\& 0 \\\\\\\\\n (1\\-t) \\& t \\& 0 \\& 0 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\& 0 \\\\\\\\\n (1\\-t)^3 \\& 3(1\\-t)^2 t \\& 3(1\\-t)t^2 \\& t^3 \\\\\\\\\n (1\\-t)^3 \\& 3(1\\-t)^2 t \\& 3(1\\-t)t^2 \\& t^3 \\\\\\\\\n 0 \\& (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n 0 \\& 0 \\& (1\\-t) \\& t \\\\\\\\\n 0 \\& 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\\\\\\n\\&\n\\\\\\\\\nS\\_3 P\n\\&\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\& 0 \\\\\\\\\n (1\\-t) \\& t \\& 0 \\& 0 \\\\\\\\\n (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\& 0 \\\\\\\\\n (1\\-t)^3 \\& 3(1\\-t)^2 t \\& 3(1\\-t)t^2 \\& t^3 \\\\\\\\\n (1\\-t)^3 \\& 3(1\\-t)^2 t \\& 3(1\\-t)t^2 \\& t^3 \\\\\\\\\n 0 \\& (1\\-t)^2 \\& 2(1\\-t)t \\& t^2 \\\\\\\\\n 0 \\& 0 \\& (1\\-t) \\& t \\\\\\\\\n 0 \\& 0 \\& 0 \\& 1\n\\\\end{pmatrix}\n\\\\begin{pmatrix}\n p\\_0 \\\\\\\\\n p\\_1 \\\\\\\\\n p\\_2 \\\\\\\\\n p\\_3\n\\\\end{pmatrix}\n\\=\n\\\\begin{pmatrix}\n \\\\vert \\\\\\\\\n H\\_0 \\\\\\\\\n \\\\vert \\\\\\\\\n \\\\vert \\\\\\\\\n H\\_1 \\\\\\\\\n \\\\vert\n\\\\end{pmatrix}\\\\end{split}\\\\]\nParameters:\n* **points** ([*BezierPointsLike*](manim.typing.html#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")) – The control points of the Bézier curve.\n* **t** (*float*) – The `t`\\-value at which to split the Bézier curve.\nReturns:\nAn array containing the control points defining the two Bézier curves.\nReturn type:\n[`Point3D_Array`](manim.typing.html#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nsubdivide\\_bezier(*points*, *n\\_divisions*)[\\[source]](../_modules/manim/utils/bezier.html#subdivide_bezier)[¶](#manim.utils.bezier.subdivide_bezier \"Link to this definition\")\nSubdivide a Bézier curve into \\\\(n\\\\) subcurves which have the same shape.\nThe points at which the curve is split are located at the\narguments \\\\(t \\= \\\\frac{i}{n}\\\\), for \\\\(i \\\\in \\\\{1, ..., n\\-1\\\\}\\\\).\nSee also\n* See [`split_bezier()`](#manim.utils.bezier.split_bezier \"manim.utils.bezier.split_bezier\") for an explanation on how to split Bézier curves.\n* See [`partial_bezier_points()`](#manim.utils.bezier.partial_bezier_points \"manim.utils.bezier.partial_bezier_points\") for an extra understanding of this function.\nNote\nThe resulting subcurves can be expressed as linear combinations of\n`points`, which can be encoded in a single matrix that is precalculated\nfor 2nd and 3rd degree Bézier curves.\nAs an example for a quadratic Bézier curve: taking inspiration from the\nexplanation in [`partial_bezier_points()`](#manim.utils.bezier.partial_bezier_points \"manim.utils.bezier.partial_bezier_points\"), where the following matrix\n\\\\(P\\_2\\\\) was defined to extract the portion of a quadratic Bézier\ncurve for \\\\(t \\\\in \\[a, b]\\\\):\n\\\\\\[\\\\begin{split}P\\_2\n\\=\n\\\\begin{pmatrix}\n (1\\-a)^2 \\& 2(1\\-a)a \\& a^2 \\\\\\\\\n (1\\-a)(1\\-b) \\& a(1\\-b) \\+ (1\\-a)b \\& ab \\\\\\\\\n (1\\-b)^2 \\& 2(1\\-b)b \\& b^2\n\\\\end{pmatrix}\\\\end{split}\\\\]\nthe plan is to replace \\\\(\\[a, b]\\\\) with\n\\\\(\\\\left\\[ \\\\frac{i\\-1}{n}, \\\\frac{i}{n} \\\\right], \\\\ \\\\forall i \\\\in \\\\{1, ..., n\\\\}\\\\).\nAs an example for \\\\(n \\= 2\\\\) divisions, construct \\\\(P\\_1\\\\) for\nthe interval \\\\(\\\\left\\[ 0, \\\\frac{1}{2} \\\\right]\\\\), and \\\\(P\\_2\\\\) for the\ninterval \\\\(\\\\left\\[ \\\\frac{1}{2}, 1 \\\\right]\\\\):\n\\\\\\[\\\\begin{split}P\\_1\n\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n 0\\.5 \\& 0\\.5 \\& 0 \\\\\\\\\n 0\\.25 \\& 0\\.5 \\& 0\\.25\n\\\\end{pmatrix}\n,\n\\\\quad\nP\\_2\n\\=\n\\\\begin{pmatrix}\n 0\\.25 \\& 0\\.5 \\& 0\\.25 \\\\\\\\\n 0 \\& 0\\.5 \\& 0\\.5 \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\\\\end{split}\\\\]\nTherefore, the following \\\\((6, 3\\)\\\\) subdivision matrix \\\\(D\\_2\\\\) can be\nconstructed, which will subdivide an array of `points` into 2 parts:\n\\\\\\[\\\\begin{split}D\\_2\n\\=\n\\\\begin{pmatrix}\n M\\_1 \\\\\\\\\n M\\_2\n\\\\end{pmatrix}\n\\=\n\\\\begin{pmatrix}\n 1 \\& 0 \\& 0 \\\\\\\\\n 0\\.5 \\& 0\\.5 \\& 0 \\\\\\\\\n 0\\.25 \\& 0\\.5 \\& 0\\.25 \\\\\\\\\n 0\\.25 \\& 0\\.5 \\& 0\\.25 \\\\\\\\\n 0 \\& 0\\.5 \\& 0\\.5 \\\\\\\\\n 0 \\& 0 \\& 1\n\\\\end{pmatrix}\\\\end{split}\\\\]\nFor quadratic and cubic Bézier curves, the subdivision matrices are memoized for\nefficiency. For higher degree curves, an iterative algorithm inspired by the\none from [`split_bezier()`](#manim.utils.bezier.split_bezier \"manim.utils.bezier.split_bezier\") is used instead.\n![../_images/bezier_subdivision_example.png](../_images/bezier_subdivision_example.png)\nParameters:\n* **points** ([*BezierPointsLike*](manim.typing.html#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")) – The control points of the Bézier curve.\n* **n\\_divisions** (*int*) – The number of curves to subdivide the Bézier curve into\nReturns:\nAn array containing the points defining the new \\\\(n\\\\) subcurves.\nReturn type:\n[`Spline`](manim.typing.html#manim.typing.Spline \"manim.typing.Spline\")",
  "scraped_at": "2025-06-24T18:34:35.825186",
  "content_length": 47105,
  "domain": "docs.manim.community",
  "word_count": 6040,
  "inspection_status": "approved",
  "filename": "bezier - Manim Community v0.19.0_20250624_183435.json",
  "saved_at": "2025-06-24T18:34:35.825458",
  "approved_at": "2025-06-25T17:18:58.458992"
}