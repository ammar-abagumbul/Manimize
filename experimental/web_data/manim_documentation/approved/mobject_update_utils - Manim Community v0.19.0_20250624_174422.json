{
  "doc_id": "fac493e60ffc19ab38f34cb933c1d536",
  "url": "https://docs.manim.community/en/latest/reference/manim.animation.updaters.mobject_update_utils.html",
  "title": "mobject_update_utils - Manim Community v0.19.0",
  "content": "mobject\\_update\\_utils[¶](#module-manim.animation.updaters.mobject_update_utils \"Link to this heading\")\n=======================================================================================================\nUtility functions for continuous animation of mobjects.\nFunctions\nalways(*method*, *\\*args*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#always)[¶](#manim.animation.updaters.mobject_update_utils.always \"Link to this definition\")\nParameters:\n**method** (*Callable*)\nReturn type:\n[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nalways\\_redraw(*func*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#always_redraw)[¶](#manim.animation.updaters.mobject_update_utils.always_redraw \"Link to this definition\")\nRedraw the mobject constructed by a function every frame.\nThis function returns a mobject with an attached updater that\ncontinuously regenerates the mobject according to the\nspecified function.\nParameters:\n**func** (*Callable**\\[**\\[**]**,* [*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]*) – A function without (required) input arguments that returns\na mobject.\nReturn type:\n[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nExamples\nExample: TangentAnimation [¶](#tangentanimation)\n```\nfrom manim import *\nclass TangentAnimation(Scene):\n    def construct(self):\n        ax = Axes()\n        sine = ax.plot(np.sin, color=RED)\n        alpha = ValueTracker(0)\n        point = always_redraw(\n            lambda: Dot(\n                sine.point_from_proportion(alpha.get_value()),\n                color=BLUE\n            )\n        )\n        tangent = always_redraw(\n            lambda: TangentLine(\n                sine,\n                alpha=alpha.get_value(),\n                color=YELLOW,\n                length=4\n            )\n        )\n        self.add(ax, sine, point, tangent)\n        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)\n```\n```\nclass TangentAnimation(Scene):\n    def construct(self):\n        ax = Axes()\n        sine = ax.plot(np.sin, color=RED)\n        alpha = ValueTracker(0)\n        point = always_redraw(\n            lambda: Dot(\n                sine.point_from_proportion(alpha.get_value()),\n                color=BLUE\n            )\n        )\n        tangent = always_redraw(\n            lambda: TangentLine(\n                sine,\n                alpha=alpha.get_value(),\n                color=YELLOW,\n                length=4\n            )\n        )\n        self.add(ax, sine, point, tangent)\n        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)\n```\nalways\\_rotate(*mobject*, *rate\\=0\\.3490658503988659*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#always_rotate)[¶](#manim.animation.updaters.mobject_update_utils.always_rotate \"Link to this definition\")\nA mobject which is continuously rotated at a certain rate.\nParameters:\n* **mobject** ([*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")) – The mobject to be rotated.\n* **rate** (*float*) – The angle which the mobject is rotated by\nover one second.\n* **kwags** – Further arguments to be passed to [`Mobject.rotate()`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject.rotate \"manim.mobject.mobject.Mobject.rotate\").\nReturn type:\n[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nExamples\nExample: SpinningTriangle [¶](#spinningtriangle)\n```\nfrom manim import *\nclass SpinningTriangle(Scene):\n    def construct(self):\n        tri = Triangle().set_fill(opacity=1).set_z_index(2)\n        sq = Square().to_edge(LEFT)\n        # will keep spinning while there is an animation going on\n        always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n        self.add(tri, sq)\n        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)\n```\n```\nclass SpinningTriangle(Scene):\n    def construct(self):\n        tri = Triangle().set_fill(opacity=1).set_z_index(2)\n        sq = Square().to_edge(LEFT)\n        # will keep spinning while there is an animation going on\n        always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n        self.add(tri, sq)\n        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)\n```\nalways\\_shift(*mobject*, *direction\\=array(\\[1\\., 0\\., 0\\.])*, *rate\\=0\\.1*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#always_shift)[¶](#manim.animation.updaters.mobject_update_utils.always_shift \"Link to this definition\")\nA mobject which is continuously shifted along some direction\nat a certain rate.\nParameters:\n* **mobject** ([*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")) – The mobject to shift.\n* **direction** (*ndarray**\\[**float64**]*) – The direction to shift. The vector is normalized, the specified magnitude\nis not relevant.\n* **rate** (*float*) – Length in Manim units which the mobject travels in one\nsecond along the specified direction.\nReturn type:\n[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nExamples\nExample: ShiftingSquare [¶](#shiftingsquare)\n```\nfrom manim import *\nclass ShiftingSquare(Scene):\n    def construct(self):\n        sq = Square().set_fill(opacity=1)\n        tri = Triangle()\n        VGroup(sq, tri).arrange(LEFT)\n        # construct a square which is continuously\n        # shifted to the right\n        always_shift(sq, RIGHT, rate=5)\n        self.add(sq)\n        self.play(tri.animate.set_fill(opacity=1))\n```\n```\nclass ShiftingSquare(Scene):\n    def construct(self):\n        sq = Square().set_fill(opacity=1)\n        tri = Triangle()\n        VGroup(sq, tri).arrange(LEFT)\n        # construct a square which is continuously\n        # shifted to the right\n        always_shift(sq, RIGHT, rate=5)\n        self.add(sq)\n        self.play(tri.animate.set_fill(opacity=1))\n```\nassert\\_is\\_mobject\\_method(*method*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#assert_is_mobject_method)[¶](#manim.animation.updaters.mobject_update_utils.assert_is_mobject_method \"Link to this definition\")\nParameters:\n**method** (*Callable*)\nReturn type:\nNone\ncycle\\_animation(*animation*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#cycle_animation)[¶](#manim.animation.updaters.mobject_update_utils.cycle_animation \"Link to this definition\")\nParameters:\n**animation** ([*Animation*](manim.animation.animation.Animation.html#manim.animation.animation.Animation \"manim.animation.animation.Animation\"))\nReturn type:\n[Mobject](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nf\\_always(*method*, *\\*arg\\_generators*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#f_always)[¶](#manim.animation.updaters.mobject_update_utils.f_always \"Link to this definition\")\nMore functional version of always, where instead\nof taking in args, it takes in functions which output\nthe relevant arguments.\nParameters:\n**method** (*Callable**\\[**\\[*[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]**,* *None**]*)\nReturn type:\n[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")\nturn\\_animation\\_into\\_updater(*animation*, *cycle\\=False*, *delay\\=0*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/animation/updaters/mobject_update_utils.html#turn_animation_into_updater)[¶](#manim.animation.updaters.mobject_update_utils.turn_animation_into_updater \"Link to this definition\")\nAdd an updater to the animation’s mobject which applies\nthe interpolation and update functions of the animation\nIf cycle is True, this repeats over and over. Otherwise,\nthe updater will be popped upon completion\nThe `delay` parameter is the delay (in seconds) before the animation starts..\nExamples\nExample: WelcomeToManim [¶](#welcometomanim)\n```\nfrom manim import *\nclass WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)\n```\n```\nclass WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)\n```\nParameters:\n* **animation** ([*Animation*](manim.animation.animation.Animation.html#manim.animation.animation.Animation \"manim.animation.animation.Animation\"))\n* **cycle** (*bool*)\n* **delay** (*float*)\nReturn type:\n[Mobject](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")",
  "scraped_at": "2025-06-24T17:44:22.012854",
  "content_length": 9272,
  "domain": "docs.manim.community",
  "word_count": 626,
  "inspection_status": "approved",
  "filename": "mobject_update_utils - Manim Community v0.19.0_20250624_174422.json",
  "saved_at": "2025-06-24T17:44:22.012920",
  "approved_at": "2025-06-25T17:18:58.403507"
}