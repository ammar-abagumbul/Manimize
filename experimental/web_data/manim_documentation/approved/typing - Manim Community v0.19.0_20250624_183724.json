{
  "doc_id": "e06cbc0d8eba72e4fcbcc67a50e20cf5",
  "url": "https://docs.manim.community/en/latest/reference/manim.typing.html",
  "title": "typing - Manim Community v0.19.0",
  "content": "typing[¶](#module-manim.typing \"Link to this heading\")\n======================================================\nCustom type definitions used in Manim.\nNote for developers\nAround the source code there are multiple strings which look like this:\n```\n'''\n[CATEGORY]\n<category_name>\n'''\n```\nAll type aliases defined under those strings will be automatically\nclassified under that category.\nIf you need to define a new category, respect the format described above.\nType Aliases\n### Primitive data types[¶](#primitive_data_types \"Link to this heading\")\n*class* ManimFloat[¶](#manim.typing.ManimFloat \"Link to this definition\")\n```\nnp.float64\n```\nA double\\-precision floating\\-point value (64 bits, or 8 bytes),\naccording to the IEEE 754 standard.\n*class* ManimInt[¶](#manim.typing.ManimInt \"Link to this definition\")\n```\nnp.int64\n```\nA long integer (64 bits, or 8 bytes).\nIt can take values between \\\\(\\-2^{63}\\\\) and \\\\(\\+2^{63} \\- 1\\\\),\nwhich expressed in base 10 is a range between around\n\\\\(\\-9\\.223 \\\\cdot 10^{18}\\\\) and \\\\(\\+9\\.223 \\\\cdot 10^{18}\\\\).\n### Color types[¶](#color_types \"Link to this heading\")\n*class* ManimColorDType[¶](#manim.typing.ManimColorDType \"Link to this definition\")\n```\n[ManimFloat](#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n```\nData type used in [`ManimColorInternal`](#manim.typing.ManimColorInternal \"manim.typing.ManimColorInternal\"): a\ndouble\\-precision float between 0 and 1\\.\n*class* RGB\\_Array\\_Float[¶](#manim.typing.RGB_Array_Float \"Link to this definition\")\n```\nNDArray[[ManimColorDType](#manim.typing.ManimColorDType \"manim.typing.ManimColorDType\")]\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in RGB format.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Tuple\\_Float[¶](#manim.typing.RGB_Tuple_Float \"Link to this definition\")\n```\ntuple[float, float, float]\n```\n`shape: (3,)`\nA tuple of 3 floats between 0 and 1, representing a color in RGB\nformat.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Array\\_Int[¶](#manim.typing.RGB_Array_Int \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 integers between 0 and 255,\nrepresenting a color in RGB format.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Tuple\\_Int[¶](#manim.typing.RGB_Tuple_Int \"Link to this definition\")\n```\ntuple[int, int, int]\n```\n`shape: (3,)`\nA tuple of 3 integers between 0 and 255, representing a color in RGB\nformat.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGBA\\_Array\\_Float[¶](#manim.typing.RGBA_Array_Float \"Link to this definition\")\n```\nNDArray[[ManimColorDType](#manim.typing.ManimColorDType \"manim.typing.ManimColorDType\")]\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 floats between 0 and 1, representing a\ncolor in RGBA format.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Tuple\\_Float[¶](#manim.typing.RGBA_Tuple_Float \"Link to this definition\")\n```\ntuple[float, float, float, float]\n```\n`shape: (4,)`\nA tuple of 4 floats between 0 and 1, representing a color in RGBA\nformat.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Array\\_Int[¶](#manim.typing.RGBA_Array_Int \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 integers between 0 and 255,\nrepresenting a color in RGBA format.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Tuple\\_Int[¶](#manim.typing.RGBA_Tuple_Int \"Link to this definition\")\n```\ntuple[int, int, int, int]\n```\n`shape: (4,)`\nA tuple of 4 integers between 0 and 255, representing a color in RGBA\nformat.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* HSV\\_Array\\_Float[¶](#manim.typing.HSV_Array_Float \"Link to this definition\")\n```\n[RGB_Array_Float](#manim.typing.RGB_Array_Float \"manim.typing.RGB_Array_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSV (or HSB) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSV\\_Tuple\\_Float[¶](#manim.typing.HSV_Tuple_Float \"Link to this definition\")\n```\n[RGB_Tuple_Float](#manim.typing.RGB_Tuple_Float \"manim.typing.RGB_Tuple_Float\")\n```\n`shape: (3,)`\nA tuple of 3 floats between 0 and 1, representing a color in HSV (or\nHSB) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSVA\\_Array\\_Float[¶](#manim.typing.HSVA_Array_Float \"Link to this definition\")\n```\n[RGBA_Array_Float](#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 floats between 0 and 1, representing a\ncolor in HSVA (or HSBA) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSVA\\_Tuple\\_Float[¶](#manim.typing.HSVA_Tuple_Float \"Link to this definition\")\n```\n[RGBA_Tuple_Float](#manim.typing.RGBA_Tuple_Float \"manim.typing.RGBA_Tuple_Float\")\n```\n`shape: (4,)`\nA tuple of 4 floats between 0 and 1, representing a color in HSVA (or\nHSBA) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSL\\_Array\\_Float[¶](#manim.typing.HSL_Array_Float \"Link to this definition\")\n```\n[RGB_Array_Float](#manim.typing.RGB_Array_Float \"manim.typing.RGB_Array_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSL format.\nIts components describe, in order, the Hue, Saturation and Lightness\nin the represented color.\n*class* HSL\\_Tuple\\_Float[¶](#manim.typing.HSL_Tuple_Float \"Link to this definition\")\n```\n[RGB_Tuple_Float](#manim.typing.RGB_Tuple_Float \"manim.typing.RGB_Tuple_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSL format.\nIts components describe, in order, the Hue, Saturation and Lightness\nin the represented color.\n*class* ManimColorInternal[¶](#manim.typing.ManimColorInternal \"Link to this definition\")\n```\n[RGBA_Array_Float](#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\n```\n`shape: (4,)`\nInternal color representation used by [`ManimColor`](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\"),\nfollowing the RGBA format.\nIt is a `numpy.ndarray` consisting of 4 floats between 0 and\n1, describing respectively the intensities of Red, Green, Blue and\nAlpha (opacity) in the represented color.\n### Point types[¶](#point_types \"Link to this heading\")\n*class* PointDType[¶](#manim.typing.PointDType \"Link to this definition\")\n```\n[ManimFloat](#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n```\nDefault type for arrays representing points: a double\\-precision\nfloating point value.\n*class* Point2D[¶](#manim.typing.Point2D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (2,)`\nA NumPy array representing a 2\\-dimensional point: `[float, float]`.\n*class* Point2DLike[¶](#manim.typing.Point2DLike \"Link to this definition\")\n```\n[Point2D](#manim.typing.Point2D \"manim.typing.Point2D\") | tuple[float, float]\n```\n`shape: (2,)`\nA 2\\-dimensional point: `[float, float]`.\nThis represents anything which can be converted to a :class:[`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") NumPy\narray.\nNormally, a function or method which expects a [`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") as a\nparameter can handle being passed a [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") instead.\n*class* Point2D\\_Array[¶](#manim.typing.Point2D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 2)`\nA NumPy array representing a sequence of [`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") objects:\n`[[float, float], ...]`.\n*class* Point2DLike\\_Array[¶](#manim.typing.Point2DLike_Array \"Link to this definition\")\n```\n[Point2D_Array](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\") | Sequence[[Point2DLike](#manim.typing.Point2DLike \"manim.typing.Point2DLike\")]\n```\n`shape: (M, 2)`\nAn array of [`Point2DLike`](#manim.typing.Point2DLike \"manim.typing.Point2DLike\") objects: `[[float, float], ...]`.\nThis represents anything which can be converted to a :class:[`Point2D_Array`](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\")\nNumPy array.\nNormally, a function or method which expects a [`Point2D_Array`](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\") as a\nparameter can handle being passed a [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") instead.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* Point3D[¶](#manim.typing.Point3D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (3,)`\nA NumPy array representing a 3\\-dimensional point: `[float, float, float]`.\n*class* Point3DLike[¶](#manim.typing.Point3DLike \"Link to this definition\")\n```\n[Point3D](#manim.typing.Point3D \"manim.typing.Point3D\") | tuple[float, float, float]\n```\n`shape: (3,)`\nA 3\\-dimensional point: `[float, float, float]`.\nThis represents anything which can be converted to a :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") NumPy\narray.\n*class* Point3D\\_Array[¶](#manim.typing.Point3D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 3)`\nA NumPy array representing a sequence of [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects:\n`[[float, float, float], ...]`.\n*class* Point3DLike\\_Array[¶](#manim.typing.Point3DLike_Array \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") | Sequence[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (M, 3)`\nAn array of [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects: `[[float, float, float], ...]`.\nThis represents anything which can be converted to a :class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* PointND[¶](#manim.typing.PointND \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N,)`\nA NumPy array representing an N\\-dimensional point: `[float, ...]`.\n*class* PointNDLike[¶](#manim.typing.PointNDLike \"Link to this definition\")\n```\n[PointND](#manim.typing.PointND \"manim.typing.PointND\") | Sequence[float]\n```\n`shape: (N,)`\nAn N\\-dimensional point: `[float, ...]`.\nThis represents anything which can be converted to a :class:[`PointND`](#manim.typing.PointND \"manim.typing.PointND\") NumPy\narray.\n*class* PointND\\_Array[¶](#manim.typing.PointND_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, N)`\nA NumPy array representing a sequence of [`PointND`](#manim.typing.PointND \"manim.typing.PointND\") objects:\n`[[float, ...], ...]`.\n*class* PointNDLike\\_Array[¶](#manim.typing.PointNDLike_Array \"Link to this definition\")\n```\n[PointND_Array](#manim.typing.PointND_Array \"manim.typing.PointND_Array\") | Sequence[[PointNDLike](#manim.typing.PointNDLike \"manim.typing.PointNDLike\")]\n```\n`shape: (M, N)`\nAn array of [`PointND`](#manim.typing.PointND \"manim.typing.PointND\") objects: `[[float, ...], ...]`.\nThis represents anything which can be converted to a :class:[`PointND_Array`](#manim.typing.PointND_Array \"manim.typing.PointND_Array\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n### Vector types[¶](#vector_types \"Link to this heading\")\n*class* Vector2D[¶](#manim.typing.Vector2D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (2,)`\nA 2\\-dimensional vector: `[float, float]`.\nNormally, a function or method which expects a [`Vector2D`](#manim.typing.Vector2D \"manim.typing.Vector2D\") as a\nparameter can handle being passed a [`Vector3D`](#manim.typing.Vector3D \"manim.typing.Vector3D\") instead.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") or [`Arrow`](manim.mobject.geometry.line.Arrow.html#manim.mobject.geometry.line.Arrow \"manim.mobject.geometry.line.Arrow\")\nVMobjects!\n*class* Vector2D\\_Array[¶](#manim.typing.Vector2D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 2)`\nAn array of [`Vector2D`](#manim.typing.Vector2D \"manim.typing.Vector2D\") objects: `[[float, float], ...]`.\nNormally, a function or method which expects a [`Vector2D_Array`](#manim.typing.Vector2D_Array \"manim.typing.Vector2D_Array\") as a\nparameter can handle being passed a [`Vector3D_Array`](#manim.typing.Vector3D_Array \"manim.typing.Vector3D_Array\") instead.\n*class* Vector3D[¶](#manim.typing.Vector3D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (3,)`\nA 3\\-dimensional vector: `[float, float, float]`.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") or [`Arrow3D`](manim.mobject.three_d.three_dimensions.Arrow3D.html#manim.mobject.three_d.three_dimensions.Arrow3D \"manim.mobject.three_d.three_dimensions.Arrow3D\")\nVMobjects!\n*class* Vector3D\\_Array[¶](#manim.typing.Vector3D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 3)`\nAn array of [`Vector3D`](#manim.typing.Vector3D \"manim.typing.Vector3D\") objects: `[[float, float, float], ...]`.\n*class* VectorND[¶](#manim.typing.VectorND \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape (N,)`\nAn \\\\(N\\\\)\\-dimensional vector: `[float, ...]`.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") VMobject! This type alias\nis named “VectorND” instead of “Vector” to avoid potential name\ncollisions.\n*class* VectorND\\_Array[¶](#manim.typing.VectorND_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape (M, N)`\nAn array of [`VectorND`](#manim.typing.VectorND \"manim.typing.VectorND\") objects: `[[float, ...], ...]`.\n*class* RowVector[¶](#manim.typing.RowVector \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (1, N)`\nA row vector: `[[float, ...]]`.\n*class* ColVector[¶](#manim.typing.ColVector \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 1)`\nA column vector: `[[float], [float], ...]`.\n### Matrix types[¶](#matrix_types \"Link to this heading\")\n*class* MatrixMN[¶](#manim.typing.MatrixMN \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, N)`\nA matrix: `[[float, ...], [float, ...], ...]`.\n*class* Zeros[¶](#manim.typing.Zeros \"Link to this definition\")\n```\n[MatrixMN](#manim.typing.MatrixMN \"manim.typing.MatrixMN\")\n```\n`shape: (M, N)`\nA [`MatrixMN`](#manim.typing.MatrixMN \"manim.typing.MatrixMN\") filled with zeros, typically created with\n`numpy.zeros((M, N))`.\n### Bézier types[¶](#bézier_types \"Link to this heading\")\n*class* QuadraticBezierPoints[¶](#manim.typing.QuadraticBezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (3, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of three 3D control points for a single quadratic Bézier\ncurve:\n`[[float, float, float], [float, float, float], [float, float, float]]`.\n*class* QuadraticBezierPointsLike[¶](#manim.typing.QuadraticBezierPointsLike \"Link to this definition\")\n```\n[QuadraticBezierPoints](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") | tuple[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (3, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of three 3D control points for a single quadratic Bézier\ncurve:\n`[[float, float, float], [float, float, float], [float, float, float]]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPoints`](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") NumPy array.\n*class* QuadraticBezierPoints\\_Array[¶](#manim.typing.QuadraticBezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 3, 3)`\nA NumPy array containing \\\\(N\\\\) [`QuadraticBezierPoints`](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float]], ...]`.\n*class* QuadraticBezierPointsLike\\_Array[¶](#manim.typing.QuadraticBezierPointsLike_Array \"Link to this definition\")\n```\n[QuadraticBezierPoints_Array](#manim.typing.QuadraticBezierPoints_Array \"manim.typing.QuadraticBezierPoints_Array\") | Sequence[[QuadraticBezierPointsLike](#manim.typing.QuadraticBezierPointsLike \"manim.typing.QuadraticBezierPointsLike\")]\n```\n`shape: (N, 3, 3)`\nA sequence of \\\\(N\\\\) [`QuadraticBezierPointsLike`](#manim.typing.QuadraticBezierPointsLike \"manim.typing.QuadraticBezierPointsLike\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float]], ...]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPoints_Array`](#manim.typing.QuadraticBezierPoints_Array \"manim.typing.QuadraticBezierPoints_Array\") NumPy array.\n*class* QuadraticBezierPath[¶](#manim.typing.QuadraticBezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (3*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(3N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 3 points represents a quadratic\nBézier curve:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticBezierPathLike[¶](#manim.typing.QuadraticBezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (3*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(3N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 3 points represents a quadratic\nBézier curve:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPath`](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticSpline[¶](#manim.typing.QuadraticSpline \"Link to this definition\")\n```\n[QuadraticBezierPath](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\")\n```\n`shape: (3*N, 3)`\nA special case of [`QuadraticBezierPath`](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\") where all the \\\\(N\\\\)\nquadratic Bézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticSplineLike[¶](#manim.typing.QuadraticSplineLike \"Link to this definition\")\n```\n[QuadraticBezierPathLike](#manim.typing.QuadraticBezierPathLike \"manim.typing.QuadraticBezierPathLike\")\n```\n`shape: (3*N, 3)`\nA special case of [`QuadraticBezierPathLike`](#manim.typing.QuadraticBezierPathLike \"manim.typing.QuadraticBezierPathLike\") where all the \\\\(N\\\\)\nquadratic Bézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a :class:[`QuadraticSpline`](#manim.typing.QuadraticSpline \"manim.typing.QuadraticSpline\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicBezierPoints[¶](#manim.typing.CubicBezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (4, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of four 3D control points for a single cubic Bézier curve:\n`[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]`.\n*class* CubicBezierPointsLike[¶](#manim.typing.CubicBezierPointsLike \"Link to this definition\")\n```\n[CubicBezierPoints](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\") | tuple[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (4, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of 4 control points for a single cubic Bézier curve:\n`[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]`.\nThis represents anything which can be converted to a :class:[`CubicBezierPoints`](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\")\nNumPy array.\n*class* CubicBezierPoints\\_Array[¶](#manim.typing.CubicBezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 4, 3)`\nA NumPy array containing \\\\(N\\\\) [`CubicBezierPoints`](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]`.\n*class* CubicBezierPointsLike\\_Array[¶](#manim.typing.CubicBezierPointsLike_Array \"Link to this definition\")\n```\n[CubicBezierPoints_Array](#manim.typing.CubicBezierPoints_Array \"manim.typing.CubicBezierPoints_Array\") | Sequence[[CubicBezierPointsLike](#manim.typing.CubicBezierPointsLike \"manim.typing.CubicBezierPointsLike\")]\n```\n`shape: (N, 4, 3)`\nA sequence of \\\\(N\\\\) [`CubicBezierPointsLike`](#manim.typing.CubicBezierPointsLike \"manim.typing.CubicBezierPointsLike\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicBezierPoints_Array`](#manim.typing.CubicBezierPoints_Array \"manim.typing.CubicBezierPoints_Array\") NumPy array.\n*class* CubicBezierPath[¶](#manim.typing.CubicBezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (4*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(4N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 4 points represents a cubic Bézier\ncurve:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicBezierPathLike[¶](#manim.typing.CubicBezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (4*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(4N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 4 points represents a cubic Bézier\ncurve:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicSpline[¶](#manim.typing.CubicSpline \"Link to this definition\")\n```\n[CubicBezierPath](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\")\n```\n`shape: (4*N, 3)`\nA special case of [`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") where all the \\\\(N\\\\) cubic\nBézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicSplineLike[¶](#manim.typing.CubicSplineLike \"Link to this definition\")\n```\n[CubicBezierPathLike](#manim.typing.CubicBezierPathLike \"manim.typing.CubicBezierPathLike\")\n```\n`shape: (4*N, 3)`\nA special case of [`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") where all the \\\\(N\\\\) cubic\nBézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicSpline`](#manim.typing.CubicSpline \"manim.typing.CubicSpline\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPoints[¶](#manim.typing.BezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (PPC, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(\\\\text{PPC}\\\\) control points\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) for a single\n\\\\(n\\\\)\\-th degree Bézier curve:\n`[[float, float, float], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPointsLike[¶](#manim.typing.BezierPointsLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (PPC, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(\\\\text{PPC}\\\\) control points\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) for a single\n\\\\(n\\\\)\\-th degree Bézier curve:\n`[[float, float, float], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPoints`](#manim.typing.BezierPoints \"manim.typing.BezierPoints\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPoints\\_Array[¶](#manim.typing.BezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, PPC, 3)`\nA NumPy array of \\\\(N\\\\) [`BezierPoints`](#manim.typing.BezierPoints \"manim.typing.BezierPoints\") objects containing\n\\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects each\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)):\n`[[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPointsLike\\_Array[¶](#manim.typing.BezierPointsLike_Array \"Link to this definition\")\n```\n[BezierPoints_Array](#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\") | Sequence[[BezierPointsLike](#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")]\n```\n`shape: (N, PPC, 3)`\nA sequence of \\\\(N\\\\) [`BezierPointsLike`](#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\") objects containing\n\\\\(\\\\text{PPC}\\\\) [`Point3DLike`](#manim.typing.Point3DLike \"manim.typing.Point3DLike\") objects each\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)):\n`[[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPoints_Array`](#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPath[¶](#manim.typing.BezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (PPC*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(\\\\text{PPC} \\\\cdot N\\\\) points, where each\none of the \\\\(N\\\\) consecutive blocks of \\\\(\\\\text{PPC}\\\\) control\npoints (\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) represents a\nBézier curve of \\\\(n\\\\)\\-th degree:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPathLike[¶](#manim.typing.BezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (PPC*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(\\\\text{PPC} \\\\cdot N\\\\) points, where each\none of the \\\\(N\\\\) consecutive blocks of \\\\(\\\\text{PPC}\\\\) control\npoints (\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) represents a\nBézier curve of \\\\(n\\\\)\\-th degree:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPath`](#manim.typing.BezierPath \"manim.typing.BezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* Spline[¶](#manim.typing.Spline \"Link to this definition\")\n```\n[BezierPath](#manim.typing.BezierPath \"manim.typing.BezierPath\")\n```\n`shape: (PPC*N, 3)`\nA special case of [`BezierPath`](#manim.typing.BezierPath \"manim.typing.BezierPath\") where all the \\\\(N\\\\) Bézier curves\nconsisting of \\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) are connected, forming\nan \\\\(n\\\\)\\-th degree spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* SplineLike[¶](#manim.typing.SplineLike \"Link to this definition\")\n```\n[BezierPathLike](#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\")\n```\n`shape: (PPC*N, 3)`\nA special case of [`BezierPathLike`](#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\") where all the \\\\(N\\\\) Bézier curves\nconsisting of \\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) are connected, forming\nan \\\\(n\\\\)\\-th degree spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`Spline`](#manim.typing.Spline \"manim.typing.Spline\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* FlatBezierPoints[¶](#manim.typing.FlatBezierPoints \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")] | tuple[float, ...]\n```\n`shape: (3*PPC*N,)`\nA flattened array of Bézier control points:\n`[float, ...]`.\n### Function types[¶](#function_types \"Link to this heading\")\n*class* FunctionOverride[¶](#manim.typing.FunctionOverride \"Link to this definition\")\n```\nCallable\n```\nFunction type returning an [`Animation`](manim.animation.animation.Animation.html#manim.animation.animation.Animation \"manim.animation.animation.Animation\") for the specified\n[`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\").\n*class* PathFuncType[¶](#manim.typing.PathFuncType \"Link to this definition\")\n```\nCallable[[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), float], [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\nFunction mapping two :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects and an alpha value to a new\n:class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\").\n*class* MappingFunction[¶](#manim.typing.MappingFunction \"Link to this definition\")\n```\nCallable[[[Point3D](#manim.typing.Point3D \"manim.typing.Point3D\")], [Point3D](#manim.typing.Point3D \"manim.typing.Point3D\")]\n```\nA function mapping a :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") to another :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\").\n*class* MultiMappingFunction[¶](#manim.typing.MultiMappingFunction \"Link to this definition\")\n```\nCallable[[[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")], [Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\n```\nA function mapping a :class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") to another\n:class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\").\n### Image types[¶](#image_types \"Link to this heading\")\n*class* PixelArray[¶](#manim.typing.PixelArray \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (height, width) | (height, width, 3) | (height, width, 4)`\nA rasterized image with a height of `height` pixels and a width of\n`width` pixels.\nEvery value in the array is an integer from 0 to 255\\.\nEvery pixel is represented either by a single integer indicating its\nlightness (for greyscale images), an [`RGB_Array_Int`](#manim.typing.RGB_Array_Int \"manim.typing.RGB_Array_Int\") or an\n[`RGBA_Array_Int`](#manim.typing.RGBA_Array_Int \"manim.typing.RGBA_Array_Int\").\n*class* GrayscalePixelArray[¶](#manim.typing.GrayscalePixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width)`\nA 100% opaque grayscale [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\"), where every pixel value is a\n[`ManimInt`](#manim.typing.ManimInt \"manim.typing.ManimInt\") indicating its lightness (black \\-\\> gray \\-\\> white).\n*class* RGBPixelArray[¶](#manim.typing.RGBPixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width, 3)`\nA 100% opaque [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\") in color, where every pixel value is an\n[`RGB_Array_Int`](#manim.typing.RGB_Array_Int \"manim.typing.RGB_Array_Int\") object.\n*class* RGBAPixelArray[¶](#manim.typing.RGBAPixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width, 4)`\nA [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\") in color where pixels can be transparent. Every pixel\nvalue is an [`RGBA_Array_Int`](#manim.typing.RGBA_Array_Int \"manim.typing.RGBA_Array_Int\") object.\n### Path types[¶](#path_types \"Link to this heading\")\n*class* StrPath[¶](#manim.typing.StrPath \"Link to this definition\")\n```\nstr | PathLike[str]\n```\nA string or `os.PathLike` representing a path to a\ndirectory or file.\n*class* StrOrBytesPath[¶](#manim.typing.StrOrBytesPath \"Link to this definition\")\n```\nstr | bytes | PathLike[str] | PathLike[bytes]\n```\nA string, bytes or `os.PathLike` object representing a path\nto a directory or file.\nType Aliases\n### Primitive data types[¶](#primitive_data_types \"Link to this heading\")\n*class* ManimFloat[¶](#manim.typing.ManimFloat \"Link to this definition\")\n```\nnp.float64\n```\nA double\\-precision floating\\-point value (64 bits, or 8 bytes),\naccording to the IEEE 754 standard.\n*class* ManimInt[¶](#manim.typing.ManimInt \"Link to this definition\")\n```\nnp.int64\n```\nA long integer (64 bits, or 8 bytes).\nIt can take values between \\\\(\\-2^{63}\\\\) and \\\\(\\+2^{63} \\- 1\\\\),\nwhich expressed in base 10 is a range between around\n\\\\(\\-9\\.223 \\\\cdot 10^{18}\\\\) and \\\\(\\+9\\.223 \\\\cdot 10^{18}\\\\).\n### Color types[¶](#color_types \"Link to this heading\")\n*class* ManimColorDType[¶](#manim.typing.ManimColorDType \"Link to this definition\")\n```\n[ManimFloat](#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n```\nData type used in [`ManimColorInternal`](#manim.typing.ManimColorInternal \"manim.typing.ManimColorInternal\"): a\ndouble\\-precision float between 0 and 1\\.\n*class* RGB\\_Array\\_Float[¶](#manim.typing.RGB_Array_Float \"Link to this definition\")\n```\nNDArray[[ManimColorDType](#manim.typing.ManimColorDType \"manim.typing.ManimColorDType\")]\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in RGB format.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Tuple\\_Float[¶](#manim.typing.RGB_Tuple_Float \"Link to this definition\")\n```\ntuple[float, float, float]\n```\n`shape: (3,)`\nA tuple of 3 floats between 0 and 1, representing a color in RGB\nformat.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Array\\_Int[¶](#manim.typing.RGB_Array_Int \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 integers between 0 and 255,\nrepresenting a color in RGB format.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Tuple\\_Int[¶](#manim.typing.RGB_Tuple_Int \"Link to this definition\")\n```\ntuple[int, int, int]\n```\n`shape: (3,)`\nA tuple of 3 integers between 0 and 255, representing a color in RGB\nformat.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGBA\\_Array\\_Float[¶](#manim.typing.RGBA_Array_Float \"Link to this definition\")\n```\nNDArray[[ManimColorDType](#manim.typing.ManimColorDType \"manim.typing.ManimColorDType\")]\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 floats between 0 and 1, representing a\ncolor in RGBA format.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Tuple\\_Float[¶](#manim.typing.RGBA_Tuple_Float \"Link to this definition\")\n```\ntuple[float, float, float, float]\n```\n`shape: (4,)`\nA tuple of 4 floats between 0 and 1, representing a color in RGBA\nformat.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Array\\_Int[¶](#manim.typing.RGBA_Array_Int \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 integers between 0 and 255,\nrepresenting a color in RGBA format.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Tuple\\_Int[¶](#manim.typing.RGBA_Tuple_Int \"Link to this definition\")\n```\ntuple[int, int, int, int]\n```\n`shape: (4,)`\nA tuple of 4 integers between 0 and 255, representing a color in RGBA\nformat.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* HSV\\_Array\\_Float[¶](#manim.typing.HSV_Array_Float \"Link to this definition\")\n```\n[RGB_Array_Float](#manim.typing.RGB_Array_Float \"manim.typing.RGB_Array_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSV (or HSB) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSV\\_Tuple\\_Float[¶](#manim.typing.HSV_Tuple_Float \"Link to this definition\")\n```\n[RGB_Tuple_Float](#manim.typing.RGB_Tuple_Float \"manim.typing.RGB_Tuple_Float\")\n```\n`shape: (3,)`\nA tuple of 3 floats between 0 and 1, representing a color in HSV (or\nHSB) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSVA\\_Array\\_Float[¶](#manim.typing.HSVA_Array_Float \"Link to this definition\")\n```\n[RGBA_Array_Float](#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 floats between 0 and 1, representing a\ncolor in HSVA (or HSBA) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSVA\\_Tuple\\_Float[¶](#manim.typing.HSVA_Tuple_Float \"Link to this definition\")\n```\n[RGBA_Tuple_Float](#manim.typing.RGBA_Tuple_Float \"manim.typing.RGBA_Tuple_Float\")\n```\n`shape: (4,)`\nA tuple of 4 floats between 0 and 1, representing a color in HSVA (or\nHSBA) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSL\\_Array\\_Float[¶](#manim.typing.HSL_Array_Float \"Link to this definition\")\n```\n[RGB_Array_Float](#manim.typing.RGB_Array_Float \"manim.typing.RGB_Array_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSL format.\nIts components describe, in order, the Hue, Saturation and Lightness\nin the represented color.\n*class* HSL\\_Tuple\\_Float[¶](#manim.typing.HSL_Tuple_Float \"Link to this definition\")\n```\n[RGB_Tuple_Float](#manim.typing.RGB_Tuple_Float \"manim.typing.RGB_Tuple_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSL format.\nIts components describe, in order, the Hue, Saturation and Lightness\nin the represented color.\n*class* ManimColorInternal[¶](#manim.typing.ManimColorInternal \"Link to this definition\")\n```\n[RGBA_Array_Float](#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\n```\n`shape: (4,)`\nInternal color representation used by [`ManimColor`](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\"),\nfollowing the RGBA format.\nIt is a `numpy.ndarray` consisting of 4 floats between 0 and\n1, describing respectively the intensities of Red, Green, Blue and\nAlpha (opacity) in the represented color.\n### Point types[¶](#point_types \"Link to this heading\")\n*class* PointDType[¶](#manim.typing.PointDType \"Link to this definition\")\n```\n[ManimFloat](#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n```\nDefault type for arrays representing points: a double\\-precision\nfloating point value.\n*class* Point2D[¶](#manim.typing.Point2D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (2,)`\nA NumPy array representing a 2\\-dimensional point: `[float, float]`.\n*class* Point2DLike[¶](#manim.typing.Point2DLike \"Link to this definition\")\n```\n[Point2D](#manim.typing.Point2D \"manim.typing.Point2D\") | tuple[float, float]\n```\n`shape: (2,)`\nA 2\\-dimensional point: `[float, float]`.\nThis represents anything which can be converted to a :class:[`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") NumPy\narray.\nNormally, a function or method which expects a [`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") as a\nparameter can handle being passed a [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") instead.\n*class* Point2D\\_Array[¶](#manim.typing.Point2D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 2)`\nA NumPy array representing a sequence of [`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") objects:\n`[[float, float], ...]`.\n*class* Point2DLike\\_Array[¶](#manim.typing.Point2DLike_Array \"Link to this definition\")\n```\n[Point2D_Array](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\") | Sequence[[Point2DLike](#manim.typing.Point2DLike \"manim.typing.Point2DLike\")]\n```\n`shape: (M, 2)`\nAn array of [`Point2DLike`](#manim.typing.Point2DLike \"manim.typing.Point2DLike\") objects: `[[float, float], ...]`.\nThis represents anything which can be converted to a :class:[`Point2D_Array`](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\")\nNumPy array.\nNormally, a function or method which expects a [`Point2D_Array`](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\") as a\nparameter can handle being passed a [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") instead.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* Point3D[¶](#manim.typing.Point3D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (3,)`\nA NumPy array representing a 3\\-dimensional point: `[float, float, float]`.\n*class* Point3DLike[¶](#manim.typing.Point3DLike \"Link to this definition\")\n```\n[Point3D](#manim.typing.Point3D \"manim.typing.Point3D\") | tuple[float, float, float]\n```\n`shape: (3,)`\nA 3\\-dimensional point: `[float, float, float]`.\nThis represents anything which can be converted to a :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") NumPy\narray.\n*class* Point3D\\_Array[¶](#manim.typing.Point3D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 3)`\nA NumPy array representing a sequence of [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects:\n`[[float, float, float], ...]`.\n*class* Point3DLike\\_Array[¶](#manim.typing.Point3DLike_Array \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") | Sequence[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (M, 3)`\nAn array of [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects: `[[float, float, float], ...]`.\nThis represents anything which can be converted to a :class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* PointND[¶](#manim.typing.PointND \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N,)`\nA NumPy array representing an N\\-dimensional point: `[float, ...]`.\n*class* PointNDLike[¶](#manim.typing.PointNDLike \"Link to this definition\")\n```\n[PointND](#manim.typing.PointND \"manim.typing.PointND\") | Sequence[float]\n```\n`shape: (N,)`\nAn N\\-dimensional point: `[float, ...]`.\nThis represents anything which can be converted to a :class:[`PointND`](#manim.typing.PointND \"manim.typing.PointND\") NumPy\narray.\n*class* PointND\\_Array[¶](#manim.typing.PointND_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, N)`\nA NumPy array representing a sequence of [`PointND`](#manim.typing.PointND \"manim.typing.PointND\") objects:\n`[[float, ...], ...]`.\n*class* PointNDLike\\_Array[¶](#manim.typing.PointNDLike_Array \"Link to this definition\")\n```\n[PointND_Array](#manim.typing.PointND_Array \"manim.typing.PointND_Array\") | Sequence[[PointNDLike](#manim.typing.PointNDLike \"manim.typing.PointNDLike\")]\n```\n`shape: (M, N)`\nAn array of [`PointND`](#manim.typing.PointND \"manim.typing.PointND\") objects: `[[float, ...], ...]`.\nThis represents anything which can be converted to a :class:[`PointND_Array`](#manim.typing.PointND_Array \"manim.typing.PointND_Array\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n### Vector types[¶](#vector_types \"Link to this heading\")\n*class* Vector2D[¶](#manim.typing.Vector2D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (2,)`\nA 2\\-dimensional vector: `[float, float]`.\nNormally, a function or method which expects a [`Vector2D`](#manim.typing.Vector2D \"manim.typing.Vector2D\") as a\nparameter can handle being passed a [`Vector3D`](#manim.typing.Vector3D \"manim.typing.Vector3D\") instead.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") or [`Arrow`](manim.mobject.geometry.line.Arrow.html#manim.mobject.geometry.line.Arrow \"manim.mobject.geometry.line.Arrow\")\nVMobjects!\n*class* Vector2D\\_Array[¶](#manim.typing.Vector2D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 2)`\nAn array of [`Vector2D`](#manim.typing.Vector2D \"manim.typing.Vector2D\") objects: `[[float, float], ...]`.\nNormally, a function or method which expects a [`Vector2D_Array`](#manim.typing.Vector2D_Array \"manim.typing.Vector2D_Array\") as a\nparameter can handle being passed a [`Vector3D_Array`](#manim.typing.Vector3D_Array \"manim.typing.Vector3D_Array\") instead.\n*class* Vector3D[¶](#manim.typing.Vector3D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (3,)`\nA 3\\-dimensional vector: `[float, float, float]`.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") or [`Arrow3D`](manim.mobject.three_d.three_dimensions.Arrow3D.html#manim.mobject.three_d.three_dimensions.Arrow3D \"manim.mobject.three_d.three_dimensions.Arrow3D\")\nVMobjects!\n*class* Vector3D\\_Array[¶](#manim.typing.Vector3D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 3)`\nAn array of [`Vector3D`](#manim.typing.Vector3D \"manim.typing.Vector3D\") objects: `[[float, float, float], ...]`.\n*class* VectorND[¶](#manim.typing.VectorND \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape (N,)`\nAn \\\\(N\\\\)\\-dimensional vector: `[float, ...]`.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") VMobject! This type alias\nis named “VectorND” instead of “Vector” to avoid potential name\ncollisions.\n*class* VectorND\\_Array[¶](#manim.typing.VectorND_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape (M, N)`\nAn array of [`VectorND`](#manim.typing.VectorND \"manim.typing.VectorND\") objects: `[[float, ...], ...]`.\n*class* RowVector[¶](#manim.typing.RowVector \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (1, N)`\nA row vector: `[[float, ...]]`.\n*class* ColVector[¶](#manim.typing.ColVector \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 1)`\nA column vector: `[[float], [float], ...]`.\n### Matrix types[¶](#matrix_types \"Link to this heading\")\n*class* MatrixMN[¶](#manim.typing.MatrixMN \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, N)`\nA matrix: `[[float, ...], [float, ...], ...]`.\n*class* Zeros[¶](#manim.typing.Zeros \"Link to this definition\")\n```\n[MatrixMN](#manim.typing.MatrixMN \"manim.typing.MatrixMN\")\n```\n`shape: (M, N)`\nA [`MatrixMN`](#manim.typing.MatrixMN \"manim.typing.MatrixMN\") filled with zeros, typically created with\n`numpy.zeros((M, N))`.\n### Bézier types[¶](#bézier_types \"Link to this heading\")\n*class* QuadraticBezierPoints[¶](#manim.typing.QuadraticBezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (3, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of three 3D control points for a single quadratic Bézier\ncurve:\n`[[float, float, float], [float, float, float], [float, float, float]]`.\n*class* QuadraticBezierPointsLike[¶](#manim.typing.QuadraticBezierPointsLike \"Link to this definition\")\n```\n[QuadraticBezierPoints](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") | tuple[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (3, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of three 3D control points for a single quadratic Bézier\ncurve:\n`[[float, float, float], [float, float, float], [float, float, float]]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPoints`](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") NumPy array.\n*class* QuadraticBezierPoints\\_Array[¶](#manim.typing.QuadraticBezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 3, 3)`\nA NumPy array containing \\\\(N\\\\) [`QuadraticBezierPoints`](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float]], ...]`.\n*class* QuadraticBezierPointsLike\\_Array[¶](#manim.typing.QuadraticBezierPointsLike_Array \"Link to this definition\")\n```\n[QuadraticBezierPoints_Array](#manim.typing.QuadraticBezierPoints_Array \"manim.typing.QuadraticBezierPoints_Array\") | Sequence[[QuadraticBezierPointsLike](#manim.typing.QuadraticBezierPointsLike \"manim.typing.QuadraticBezierPointsLike\")]\n```\n`shape: (N, 3, 3)`\nA sequence of \\\\(N\\\\) [`QuadraticBezierPointsLike`](#manim.typing.QuadraticBezierPointsLike \"manim.typing.QuadraticBezierPointsLike\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float]], ...]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPoints_Array`](#manim.typing.QuadraticBezierPoints_Array \"manim.typing.QuadraticBezierPoints_Array\") NumPy array.\n*class* QuadraticBezierPath[¶](#manim.typing.QuadraticBezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (3*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(3N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 3 points represents a quadratic\nBézier curve:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticBezierPathLike[¶](#manim.typing.QuadraticBezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (3*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(3N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 3 points represents a quadratic\nBézier curve:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPath`](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticSpline[¶](#manim.typing.QuadraticSpline \"Link to this definition\")\n```\n[QuadraticBezierPath](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\")\n```\n`shape: (3*N, 3)`\nA special case of [`QuadraticBezierPath`](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\") where all the \\\\(N\\\\)\nquadratic Bézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticSplineLike[¶](#manim.typing.QuadraticSplineLike \"Link to this definition\")\n```\n[QuadraticBezierPathLike](#manim.typing.QuadraticBezierPathLike \"manim.typing.QuadraticBezierPathLike\")\n```\n`shape: (3*N, 3)`\nA special case of [`QuadraticBezierPathLike`](#manim.typing.QuadraticBezierPathLike \"manim.typing.QuadraticBezierPathLike\") where all the \\\\(N\\\\)\nquadratic Bézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a :class:[`QuadraticSpline`](#manim.typing.QuadraticSpline \"manim.typing.QuadraticSpline\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicBezierPoints[¶](#manim.typing.CubicBezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (4, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of four 3D control points for a single cubic Bézier curve:\n`[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]`.\n*class* CubicBezierPointsLike[¶](#manim.typing.CubicBezierPointsLike \"Link to this definition\")\n```\n[CubicBezierPoints](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\") | tuple[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (4, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of 4 control points for a single cubic Bézier curve:\n`[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]`.\nThis represents anything which can be converted to a :class:[`CubicBezierPoints`](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\")\nNumPy array.\n*class* CubicBezierPoints\\_Array[¶](#manim.typing.CubicBezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 4, 3)`\nA NumPy array containing \\\\(N\\\\) [`CubicBezierPoints`](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]`.\n*class* CubicBezierPointsLike\\_Array[¶](#manim.typing.CubicBezierPointsLike_Array \"Link to this definition\")\n```\n[CubicBezierPoints_Array](#manim.typing.CubicBezierPoints_Array \"manim.typing.CubicBezierPoints_Array\") | Sequence[[CubicBezierPointsLike](#manim.typing.CubicBezierPointsLike \"manim.typing.CubicBezierPointsLike\")]\n```\n`shape: (N, 4, 3)`\nA sequence of \\\\(N\\\\) [`CubicBezierPointsLike`](#manim.typing.CubicBezierPointsLike \"manim.typing.CubicBezierPointsLike\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicBezierPoints_Array`](#manim.typing.CubicBezierPoints_Array \"manim.typing.CubicBezierPoints_Array\") NumPy array.\n*class* CubicBezierPath[¶](#manim.typing.CubicBezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (4*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(4N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 4 points represents a cubic Bézier\ncurve:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicBezierPathLike[¶](#manim.typing.CubicBezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (4*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(4N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 4 points represents a cubic Bézier\ncurve:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicSpline[¶](#manim.typing.CubicSpline \"Link to this definition\")\n```\n[CubicBezierPath](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\")\n```\n`shape: (4*N, 3)`\nA special case of [`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") where all the \\\\(N\\\\) cubic\nBézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicSplineLike[¶](#manim.typing.CubicSplineLike \"Link to this definition\")\n```\n[CubicBezierPathLike](#manim.typing.CubicBezierPathLike \"manim.typing.CubicBezierPathLike\")\n```\n`shape: (4*N, 3)`\nA special case of [`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") where all the \\\\(N\\\\) cubic\nBézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicSpline`](#manim.typing.CubicSpline \"manim.typing.CubicSpline\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPoints[¶](#manim.typing.BezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (PPC, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(\\\\text{PPC}\\\\) control points\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) for a single\n\\\\(n\\\\)\\-th degree Bézier curve:\n`[[float, float, float], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPointsLike[¶](#manim.typing.BezierPointsLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (PPC, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(\\\\text{PPC}\\\\) control points\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) for a single\n\\\\(n\\\\)\\-th degree Bézier curve:\n`[[float, float, float], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPoints`](#manim.typing.BezierPoints \"manim.typing.BezierPoints\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPoints\\_Array[¶](#manim.typing.BezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, PPC, 3)`\nA NumPy array of \\\\(N\\\\) [`BezierPoints`](#manim.typing.BezierPoints \"manim.typing.BezierPoints\") objects containing\n\\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects each\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)):\n`[[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPointsLike\\_Array[¶](#manim.typing.BezierPointsLike_Array \"Link to this definition\")\n```\n[BezierPoints_Array](#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\") | Sequence[[BezierPointsLike](#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")]\n```\n`shape: (N, PPC, 3)`\nA sequence of \\\\(N\\\\) [`BezierPointsLike`](#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\") objects containing\n\\\\(\\\\text{PPC}\\\\) [`Point3DLike`](#manim.typing.Point3DLike \"manim.typing.Point3DLike\") objects each\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)):\n`[[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPoints_Array`](#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPath[¶](#manim.typing.BezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (PPC*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(\\\\text{PPC} \\\\cdot N\\\\) points, where each\none of the \\\\(N\\\\) consecutive blocks of \\\\(\\\\text{PPC}\\\\) control\npoints (\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) represents a\nBézier curve of \\\\(n\\\\)\\-th degree:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPathLike[¶](#manim.typing.BezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (PPC*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(\\\\text{PPC} \\\\cdot N\\\\) points, where each\none of the \\\\(N\\\\) consecutive blocks of \\\\(\\\\text{PPC}\\\\) control\npoints (\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) represents a\nBézier curve of \\\\(n\\\\)\\-th degree:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPath`](#manim.typing.BezierPath \"manim.typing.BezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* Spline[¶](#manim.typing.Spline \"Link to this definition\")\n```\n[BezierPath](#manim.typing.BezierPath \"manim.typing.BezierPath\")\n```\n`shape: (PPC*N, 3)`\nA special case of [`BezierPath`](#manim.typing.BezierPath \"manim.typing.BezierPath\") where all the \\\\(N\\\\) Bézier curves\nconsisting of \\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) are connected, forming\nan \\\\(n\\\\)\\-th degree spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* SplineLike[¶](#manim.typing.SplineLike \"Link to this definition\")\n```\n[BezierPathLike](#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\")\n```\n`shape: (PPC*N, 3)`\nA special case of [`BezierPathLike`](#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\") where all the \\\\(N\\\\) Bézier curves\nconsisting of \\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) are connected, forming\nan \\\\(n\\\\)\\-th degree spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`Spline`](#manim.typing.Spline \"manim.typing.Spline\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* FlatBezierPoints[¶](#manim.typing.FlatBezierPoints \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")] | tuple[float, ...]\n```\n`shape: (3*PPC*N,)`\nA flattened array of Bézier control points:\n`[float, ...]`.\n### Function types[¶](#function_types \"Link to this heading\")\n*class* FunctionOverride[¶](#manim.typing.FunctionOverride \"Link to this definition\")\n```\nCallable\n```\nFunction type returning an [`Animation`](manim.animation.animation.Animation.html#manim.animation.animation.Animation \"manim.animation.animation.Animation\") for the specified\n[`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\").\n*class* PathFuncType[¶](#manim.typing.PathFuncType \"Link to this definition\")\n```\nCallable[[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), float], [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\nFunction mapping two :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects and an alpha value to a new\n:class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\").\n*class* MappingFunction[¶](#manim.typing.MappingFunction \"Link to this definition\")\n```\nCallable[[[Point3D](#manim.typing.Point3D \"manim.typing.Point3D\")], [Point3D](#manim.typing.Point3D \"manim.typing.Point3D\")]\n```\nA function mapping a :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") to another :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\").\n*class* MultiMappingFunction[¶](#manim.typing.MultiMappingFunction \"Link to this definition\")\n```\nCallable[[[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")], [Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\n```\nA function mapping a :class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") to another\n:class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\").\n### Image types[¶](#image_types \"Link to this heading\")\n*class* PixelArray[¶](#manim.typing.PixelArray \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (height, width) | (height, width, 3) | (height, width, 4)`\nA rasterized image with a height of `height` pixels and a width of\n`width` pixels.\nEvery value in the array is an integer from 0 to 255\\.\nEvery pixel is represented either by a single integer indicating its\nlightness (for greyscale images), an [`RGB_Array_Int`](#manim.typing.RGB_Array_Int \"manim.typing.RGB_Array_Int\") or an\n[`RGBA_Array_Int`](#manim.typing.RGBA_Array_Int \"manim.typing.RGBA_Array_Int\").\n*class* GrayscalePixelArray[¶](#manim.typing.GrayscalePixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width)`\nA 100% opaque grayscale [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\"), where every pixel value is a\n[`ManimInt`](#manim.typing.ManimInt \"manim.typing.ManimInt\") indicating its lightness (black \\-\\> gray \\-\\> white).\n*class* RGBPixelArray[¶](#manim.typing.RGBPixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width, 3)`\nA 100% opaque [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\") in color, where every pixel value is an\n[`RGB_Array_Int`](#manim.typing.RGB_Array_Int \"manim.typing.RGB_Array_Int\") object.\n*class* RGBAPixelArray[¶](#manim.typing.RGBAPixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width, 4)`\nA [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\") in color where pixels can be transparent. Every pixel\nvalue is an [`RGBA_Array_Int`](#manim.typing.RGBA_Array_Int \"manim.typing.RGBA_Array_Int\") object.\n### Path types[¶](#path_types \"Link to this heading\")\n*class* StrPath[¶](#manim.typing.StrPath \"Link to this definition\")\n```\nstr | PathLike[str]\n```\nA string or `os.PathLike` representing a path to a\ndirectory or file.\n*class* StrOrBytesPath[¶](#manim.typing.StrOrBytesPath \"Link to this definition\")\n```\nstr | bytes | PathLike[str] | PathLike[bytes]\n```\nA string, bytes or `os.PathLike` object representing a path\nto a directory or file.\n### Primitive data types[¶](#primitive_data_types \"Link to this heading\")\n*class* ManimFloat[¶](#manim.typing.ManimFloat \"Link to this definition\")\n```\nnp.float64\n```\nA double\\-precision floating\\-point value (64 bits, or 8 bytes),\naccording to the IEEE 754 standard.\n*class* ManimInt[¶](#manim.typing.ManimInt \"Link to this definition\")\n```\nnp.int64\n```\nA long integer (64 bits, or 8 bytes).\nIt can take values between \\\\(\\-2^{63}\\\\) and \\\\(\\+2^{63} \\- 1\\\\),\nwhich expressed in base 10 is a range between around\n\\\\(\\-9\\.223 \\\\cdot 10^{18}\\\\) and \\\\(\\+9\\.223 \\\\cdot 10^{18}\\\\).\n### Color types[¶](#color_types \"Link to this heading\")\n*class* ManimColorDType[¶](#manim.typing.ManimColorDType \"Link to this definition\")\n```\n[ManimFloat](#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n```\nData type used in [`ManimColorInternal`](#manim.typing.ManimColorInternal \"manim.typing.ManimColorInternal\"): a\ndouble\\-precision float between 0 and 1\\.\n*class* RGB\\_Array\\_Float[¶](#manim.typing.RGB_Array_Float \"Link to this definition\")\n```\nNDArray[[ManimColorDType](#manim.typing.ManimColorDType \"manim.typing.ManimColorDType\")]\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in RGB format.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Tuple\\_Float[¶](#manim.typing.RGB_Tuple_Float \"Link to this definition\")\n```\ntuple[float, float, float]\n```\n`shape: (3,)`\nA tuple of 3 floats between 0 and 1, representing a color in RGB\nformat.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Array\\_Int[¶](#manim.typing.RGB_Array_Int \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 integers between 0 and 255,\nrepresenting a color in RGB format.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGB\\_Tuple\\_Int[¶](#manim.typing.RGB_Tuple_Int \"Link to this definition\")\n```\ntuple[int, int, int]\n```\n`shape: (3,)`\nA tuple of 3 integers between 0 and 255, representing a color in RGB\nformat.\nIts components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.\n*class* RGBA\\_Array\\_Float[¶](#manim.typing.RGBA_Array_Float \"Link to this definition\")\n```\nNDArray[[ManimColorDType](#manim.typing.ManimColorDType \"manim.typing.ManimColorDType\")]\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 floats between 0 and 1, representing a\ncolor in RGBA format.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Tuple\\_Float[¶](#manim.typing.RGBA_Tuple_Float \"Link to this definition\")\n```\ntuple[float, float, float, float]\n```\n`shape: (4,)`\nA tuple of 4 floats between 0 and 1, representing a color in RGBA\nformat.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Array\\_Int[¶](#manim.typing.RGBA_Array_Int \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 integers between 0 and 255,\nrepresenting a color in RGBA format.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* RGBA\\_Tuple\\_Int[¶](#manim.typing.RGBA_Tuple_Int \"Link to this definition\")\n```\ntuple[int, int, int, int]\n```\n`shape: (4,)`\nA tuple of 4 integers between 0 and 255, representing a color in RGBA\nformat.\nIts components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.\n*class* HSV\\_Array\\_Float[¶](#manim.typing.HSV_Array_Float \"Link to this definition\")\n```\n[RGB_Array_Float](#manim.typing.RGB_Array_Float \"manim.typing.RGB_Array_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSV (or HSB) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSV\\_Tuple\\_Float[¶](#manim.typing.HSV_Tuple_Float \"Link to this definition\")\n```\n[RGB_Tuple_Float](#manim.typing.RGB_Tuple_Float \"manim.typing.RGB_Tuple_Float\")\n```\n`shape: (3,)`\nA tuple of 3 floats between 0 and 1, representing a color in HSV (or\nHSB) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSVA\\_Array\\_Float[¶](#manim.typing.HSVA_Array_Float \"Link to this definition\")\n```\n[RGBA_Array_Float](#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\n```\n`shape: (4,)`\nA `numpy.ndarray` of 4 floats between 0 and 1, representing a\ncolor in HSVA (or HSBA) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSVA\\_Tuple\\_Float[¶](#manim.typing.HSVA_Tuple_Float \"Link to this definition\")\n```\n[RGBA_Tuple_Float](#manim.typing.RGBA_Tuple_Float \"manim.typing.RGBA_Tuple_Float\")\n```\n`shape: (4,)`\nA tuple of 4 floats between 0 and 1, representing a color in HSVA (or\nHSBA) format.\nIts components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.\n*class* HSL\\_Array\\_Float[¶](#manim.typing.HSL_Array_Float \"Link to this definition\")\n```\n[RGB_Array_Float](#manim.typing.RGB_Array_Float \"manim.typing.RGB_Array_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSL format.\nIts components describe, in order, the Hue, Saturation and Lightness\nin the represented color.\n*class* HSL\\_Tuple\\_Float[¶](#manim.typing.HSL_Tuple_Float \"Link to this definition\")\n```\n[RGB_Tuple_Float](#manim.typing.RGB_Tuple_Float \"manim.typing.RGB_Tuple_Float\")\n```\n`shape: (3,)`\nA `numpy.ndarray` of 3 floats between 0 and 1, representing a\ncolor in HSL format.\nIts components describe, in order, the Hue, Saturation and Lightness\nin the represented color.\n*class* ManimColorInternal[¶](#manim.typing.ManimColorInternal \"Link to this definition\")\n```\n[RGBA_Array_Float](#manim.typing.RGBA_Array_Float \"manim.typing.RGBA_Array_Float\")\n```\n`shape: (4,)`\nInternal color representation used by [`ManimColor`](manim.utils.color.core.ManimColor.html#manim.utils.color.core.ManimColor \"manim.utils.color.core.ManimColor\"),\nfollowing the RGBA format.\nIt is a `numpy.ndarray` consisting of 4 floats between 0 and\n1, describing respectively the intensities of Red, Green, Blue and\nAlpha (opacity) in the represented color.\n### Point types[¶](#point_types \"Link to this heading\")\n*class* PointDType[¶](#manim.typing.PointDType \"Link to this definition\")\n```\n[ManimFloat](#manim.typing.ManimFloat \"manim.typing.ManimFloat\")\n```\nDefault type for arrays representing points: a double\\-precision\nfloating point value.\n*class* Point2D[¶](#manim.typing.Point2D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (2,)`\nA NumPy array representing a 2\\-dimensional point: `[float, float]`.\n*class* Point2DLike[¶](#manim.typing.Point2DLike \"Link to this definition\")\n```\n[Point2D](#manim.typing.Point2D \"manim.typing.Point2D\") | tuple[float, float]\n```\n`shape: (2,)`\nA 2\\-dimensional point: `[float, float]`.\nThis represents anything which can be converted to a :class:[`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") NumPy\narray.\nNormally, a function or method which expects a [`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") as a\nparameter can handle being passed a [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") instead.\n*class* Point2D\\_Array[¶](#manim.typing.Point2D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 2)`\nA NumPy array representing a sequence of [`Point2D`](#manim.typing.Point2D \"manim.typing.Point2D\") objects:\n`[[float, float], ...]`.\n*class* Point2DLike\\_Array[¶](#manim.typing.Point2DLike_Array \"Link to this definition\")\n```\n[Point2D_Array](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\") | Sequence[[Point2DLike](#manim.typing.Point2DLike \"manim.typing.Point2DLike\")]\n```\n`shape: (M, 2)`\nAn array of [`Point2DLike`](#manim.typing.Point2DLike \"manim.typing.Point2DLike\") objects: `[[float, float], ...]`.\nThis represents anything which can be converted to a :class:[`Point2D_Array`](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\")\nNumPy array.\nNormally, a function or method which expects a [`Point2D_Array`](#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\") as a\nparameter can handle being passed a [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") instead.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* Point3D[¶](#manim.typing.Point3D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (3,)`\nA NumPy array representing a 3\\-dimensional point: `[float, float, float]`.\n*class* Point3DLike[¶](#manim.typing.Point3DLike \"Link to this definition\")\n```\n[Point3D](#manim.typing.Point3D \"manim.typing.Point3D\") | tuple[float, float, float]\n```\n`shape: (3,)`\nA 3\\-dimensional point: `[float, float, float]`.\nThis represents anything which can be converted to a :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") NumPy\narray.\n*class* Point3D\\_Array[¶](#manim.typing.Point3D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 3)`\nA NumPy array representing a sequence of [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects:\n`[[float, float, float], ...]`.\n*class* Point3DLike\\_Array[¶](#manim.typing.Point3DLike_Array \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") | Sequence[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (M, 3)`\nAn array of [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects: `[[float, float, float], ...]`.\nThis represents anything which can be converted to a :class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* PointND[¶](#manim.typing.PointND \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N,)`\nA NumPy array representing an N\\-dimensional point: `[float, ...]`.\n*class* PointNDLike[¶](#manim.typing.PointNDLike \"Link to this definition\")\n```\n[PointND](#manim.typing.PointND \"manim.typing.PointND\") | Sequence[float]\n```\n`shape: (N,)`\nAn N\\-dimensional point: `[float, ...]`.\nThis represents anything which can be converted to a :class:[`PointND`](#manim.typing.PointND \"manim.typing.PointND\") NumPy\narray.\n*class* PointND\\_Array[¶](#manim.typing.PointND_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, N)`\nA NumPy array representing a sequence of [`PointND`](#manim.typing.PointND \"manim.typing.PointND\") objects:\n`[[float, ...], ...]`.\n*class* PointNDLike\\_Array[¶](#manim.typing.PointNDLike_Array \"Link to this definition\")\n```\n[PointND_Array](#manim.typing.PointND_Array \"manim.typing.PointND_Array\") | Sequence[[PointNDLike](#manim.typing.PointNDLike \"manim.typing.PointNDLike\")]\n```\n`shape: (M, N)`\nAn array of [`PointND`](#manim.typing.PointND \"manim.typing.PointND\") objects: `[[float, ...], ...]`.\nThis represents anything which can be converted to a :class:[`PointND_Array`](#manim.typing.PointND_Array \"manim.typing.PointND_Array\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n### Vector types[¶](#vector_types \"Link to this heading\")\n*class* Vector2D[¶](#manim.typing.Vector2D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (2,)`\nA 2\\-dimensional vector: `[float, float]`.\nNormally, a function or method which expects a [`Vector2D`](#manim.typing.Vector2D \"manim.typing.Vector2D\") as a\nparameter can handle being passed a [`Vector3D`](#manim.typing.Vector3D \"manim.typing.Vector3D\") instead.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") or [`Arrow`](manim.mobject.geometry.line.Arrow.html#manim.mobject.geometry.line.Arrow \"manim.mobject.geometry.line.Arrow\")\nVMobjects!\n*class* Vector2D\\_Array[¶](#manim.typing.Vector2D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 2)`\nAn array of [`Vector2D`](#manim.typing.Vector2D \"manim.typing.Vector2D\") objects: `[[float, float], ...]`.\nNormally, a function or method which expects a [`Vector2D_Array`](#manim.typing.Vector2D_Array \"manim.typing.Vector2D_Array\") as a\nparameter can handle being passed a [`Vector3D_Array`](#manim.typing.Vector3D_Array \"manim.typing.Vector3D_Array\") instead.\n*class* Vector3D[¶](#manim.typing.Vector3D \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (3,)`\nA 3\\-dimensional vector: `[float, float, float]`.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") or [`Arrow3D`](manim.mobject.three_d.three_dimensions.Arrow3D.html#manim.mobject.three_d.three_dimensions.Arrow3D \"manim.mobject.three_d.three_dimensions.Arrow3D\")\nVMobjects!\n*class* Vector3D\\_Array[¶](#manim.typing.Vector3D_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, 3)`\nAn array of [`Vector3D`](#manim.typing.Vector3D \"manim.typing.Vector3D\") objects: `[[float, float, float], ...]`.\n*class* VectorND[¶](#manim.typing.VectorND \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape (N,)`\nAn \\\\(N\\\\)\\-dimensional vector: `[float, ...]`.\nCaution\nDo not confuse with the [`Vector`](manim.mobject.geometry.line.Vector.html#manim.mobject.geometry.line.Vector \"manim.mobject.geometry.line.Vector\") VMobject! This type alias\nis named “VectorND” instead of “Vector” to avoid potential name\ncollisions.\n*class* VectorND\\_Array[¶](#manim.typing.VectorND_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape (M, N)`\nAn array of [`VectorND`](#manim.typing.VectorND \"manim.typing.VectorND\") objects: `[[float, ...], ...]`.\n*class* RowVector[¶](#manim.typing.RowVector \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (1, N)`\nA row vector: `[[float, ...]]`.\n*class* ColVector[¶](#manim.typing.ColVector \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 1)`\nA column vector: `[[float], [float], ...]`.\n### Matrix types[¶](#matrix_types \"Link to this heading\")\n*class* MatrixMN[¶](#manim.typing.MatrixMN \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (M, N)`\nA matrix: `[[float, ...], [float, ...], ...]`.\n*class* Zeros[¶](#manim.typing.Zeros \"Link to this definition\")\n```\n[MatrixMN](#manim.typing.MatrixMN \"manim.typing.MatrixMN\")\n```\n`shape: (M, N)`\nA [`MatrixMN`](#manim.typing.MatrixMN \"manim.typing.MatrixMN\") filled with zeros, typically created with\n`numpy.zeros((M, N))`.\n### Bézier types[¶](#bézier_types \"Link to this heading\")\n*class* QuadraticBezierPoints[¶](#manim.typing.QuadraticBezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (3, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of three 3D control points for a single quadratic Bézier\ncurve:\n`[[float, float, float], [float, float, float], [float, float, float]]`.\n*class* QuadraticBezierPointsLike[¶](#manim.typing.QuadraticBezierPointsLike \"Link to this definition\")\n```\n[QuadraticBezierPoints](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") | tuple[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (3, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of three 3D control points for a single quadratic Bézier\ncurve:\n`[[float, float, float], [float, float, float], [float, float, float]]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPoints`](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") NumPy array.\n*class* QuadraticBezierPoints\\_Array[¶](#manim.typing.QuadraticBezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 3, 3)`\nA NumPy array containing \\\\(N\\\\) [`QuadraticBezierPoints`](#manim.typing.QuadraticBezierPoints \"manim.typing.QuadraticBezierPoints\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float]], ...]`.\n*class* QuadraticBezierPointsLike\\_Array[¶](#manim.typing.QuadraticBezierPointsLike_Array \"Link to this definition\")\n```\n[QuadraticBezierPoints_Array](#manim.typing.QuadraticBezierPoints_Array \"manim.typing.QuadraticBezierPoints_Array\") | Sequence[[QuadraticBezierPointsLike](#manim.typing.QuadraticBezierPointsLike \"manim.typing.QuadraticBezierPointsLike\")]\n```\n`shape: (N, 3, 3)`\nA sequence of \\\\(N\\\\) [`QuadraticBezierPointsLike`](#manim.typing.QuadraticBezierPointsLike \"manim.typing.QuadraticBezierPointsLike\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float]], ...]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPoints_Array`](#manim.typing.QuadraticBezierPoints_Array \"manim.typing.QuadraticBezierPoints_Array\") NumPy array.\n*class* QuadraticBezierPath[¶](#manim.typing.QuadraticBezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (3*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(3N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 3 points represents a quadratic\nBézier curve:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticBezierPathLike[¶](#manim.typing.QuadraticBezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (3*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(3N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 3 points represents a quadratic\nBézier curve:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`QuadraticBezierPath`](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticSpline[¶](#manim.typing.QuadraticSpline \"Link to this definition\")\n```\n[QuadraticBezierPath](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\")\n```\n`shape: (3*N, 3)`\nA special case of [`QuadraticBezierPath`](#manim.typing.QuadraticBezierPath \"manim.typing.QuadraticBezierPath\") where all the \\\\(N\\\\)\nquadratic Bézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* QuadraticSplineLike[¶](#manim.typing.QuadraticSplineLike \"Link to this definition\")\n```\n[QuadraticBezierPathLike](#manim.typing.QuadraticBezierPathLike \"manim.typing.QuadraticBezierPathLike\")\n```\n`shape: (3*N, 3)`\nA special case of [`QuadraticBezierPathLike`](#manim.typing.QuadraticBezierPathLike \"manim.typing.QuadraticBezierPathLike\") where all the \\\\(N\\\\)\nquadratic Bézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a :class:[`QuadraticSpline`](#manim.typing.QuadraticSpline \"manim.typing.QuadraticSpline\")\nNumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicBezierPoints[¶](#manim.typing.CubicBezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (4, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of four 3D control points for a single cubic Bézier curve:\n`[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]`.\n*class* CubicBezierPointsLike[¶](#manim.typing.CubicBezierPointsLike \"Link to this definition\")\n```\n[CubicBezierPoints](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\") | tuple[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\n`shape: (4, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of 4 control points for a single cubic Bézier curve:\n`[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]`.\nThis represents anything which can be converted to a :class:[`CubicBezierPoints`](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\")\nNumPy array.\n*class* CubicBezierPoints\\_Array[¶](#manim.typing.CubicBezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, 4, 3)`\nA NumPy array containing \\\\(N\\\\) [`CubicBezierPoints`](#manim.typing.CubicBezierPoints \"manim.typing.CubicBezierPoints\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]`.\n*class* CubicBezierPointsLike\\_Array[¶](#manim.typing.CubicBezierPointsLike_Array \"Link to this definition\")\n```\n[CubicBezierPoints_Array](#manim.typing.CubicBezierPoints_Array \"manim.typing.CubicBezierPoints_Array\") | Sequence[[CubicBezierPointsLike](#manim.typing.CubicBezierPointsLike \"manim.typing.CubicBezierPointsLike\")]\n```\n`shape: (N, 4, 3)`\nA sequence of \\\\(N\\\\) [`CubicBezierPointsLike`](#manim.typing.CubicBezierPointsLike \"manim.typing.CubicBezierPointsLike\") objects:\n`[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicBezierPoints_Array`](#manim.typing.CubicBezierPoints_Array \"manim.typing.CubicBezierPoints_Array\") NumPy array.\n*class* CubicBezierPath[¶](#manim.typing.CubicBezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (4*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(4N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 4 points represents a cubic Bézier\ncurve:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicBezierPathLike[¶](#manim.typing.CubicBezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (4*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(4N\\\\) points, where each one of the\n\\\\(N\\\\) consecutive blocks of 4 points represents a cubic Bézier\ncurve:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicSpline[¶](#manim.typing.CubicSpline \"Link to this definition\")\n```\n[CubicBezierPath](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\")\n```\n`shape: (4*N, 3)`\nA special case of [`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") where all the \\\\(N\\\\) cubic\nBézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* CubicSplineLike[¶](#manim.typing.CubicSplineLike \"Link to this definition\")\n```\n[CubicBezierPathLike](#manim.typing.CubicBezierPathLike \"manim.typing.CubicBezierPathLike\")\n```\n`shape: (4*N, 3)`\nA special case of [`CubicBezierPath`](#manim.typing.CubicBezierPath \"manim.typing.CubicBezierPath\") where all the \\\\(N\\\\) cubic\nBézier curves are connected, forming a quadratic spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`CubicSpline`](#manim.typing.CubicSpline \"manim.typing.CubicSpline\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPoints[¶](#manim.typing.BezierPoints \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (PPC, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(\\\\text{PPC}\\\\) control points\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) for a single\n\\\\(n\\\\)\\-th degree Bézier curve:\n`[[float, float, float], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPointsLike[¶](#manim.typing.BezierPointsLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (PPC, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(\\\\text{PPC}\\\\) control points\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) for a single\n\\\\(n\\\\)\\-th degree Bézier curve:\n`[[float, float, float], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPoints`](#manim.typing.BezierPoints \"manim.typing.BezierPoints\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPoints\\_Array[¶](#manim.typing.BezierPoints_Array \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")]\n```\n`shape: (N, PPC, 3)`\nA NumPy array of \\\\(N\\\\) [`BezierPoints`](#manim.typing.BezierPoints \"manim.typing.BezierPoints\") objects containing\n\\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects each\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)):\n`[[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPointsLike\\_Array[¶](#manim.typing.BezierPointsLike_Array \"Link to this definition\")\n```\n[BezierPoints_Array](#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\") | Sequence[[BezierPointsLike](#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\")]\n```\n`shape: (N, PPC, 3)`\nA sequence of \\\\(N\\\\) [`BezierPointsLike`](#manim.typing.BezierPointsLike \"manim.typing.BezierPointsLike\") objects containing\n\\\\(\\\\text{PPC}\\\\) [`Point3DLike`](#manim.typing.Point3DLike \"manim.typing.Point3DLike\") objects each\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)):\n`[[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPoints_Array`](#manim.typing.BezierPoints_Array \"manim.typing.BezierPoints_Array\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPath[¶](#manim.typing.BezierPath \"Link to this definition\")\n```\n[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")\n```\n`shape: (PPC*N, 3)`\nA [`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") of \\\\(\\\\text{PPC} \\\\cdot N\\\\) points, where each\none of the \\\\(N\\\\) consecutive blocks of \\\\(\\\\text{PPC}\\\\) control\npoints (\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) represents a\nBézier curve of \\\\(n\\\\)\\-th degree:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* BezierPathLike[¶](#manim.typing.BezierPathLike \"Link to this definition\")\n```\n[Point3DLike_Array](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\")\n```\n`shape: (PPC*N, 3)`\nA [`Point3DLike_Array`](#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\") of \\\\(\\\\text{PPC} \\\\cdot N\\\\) points, where each\none of the \\\\(N\\\\) consecutive blocks of \\\\(\\\\text{PPC}\\\\) control\npoints (\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) represents a\nBézier curve of \\\\(n\\\\)\\-th degree:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`BezierPath`](#manim.typing.BezierPath \"manim.typing.BezierPath\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* Spline[¶](#manim.typing.Spline \"Link to this definition\")\n```\n[BezierPath](#manim.typing.BezierPath \"manim.typing.BezierPath\")\n```\n`shape: (PPC*N, 3)`\nA special case of [`BezierPath`](#manim.typing.BezierPath \"manim.typing.BezierPath\") where all the \\\\(N\\\\) Bézier curves\nconsisting of \\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) are connected, forming\nan \\\\(n\\\\)\\-th degree spline:\n`[[float, float, float], ...], ...]`.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* SplineLike[¶](#manim.typing.SplineLike \"Link to this definition\")\n```\n[BezierPathLike](#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\")\n```\n`shape: (PPC*N, 3)`\nA special case of [`BezierPathLike`](#manim.typing.BezierPathLike \"manim.typing.BezierPathLike\") where all the \\\\(N\\\\) Bézier curves\nconsisting of \\\\(\\\\text{PPC}\\\\) [`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects\n(\\\\(\\\\text{PPC: Points Per Curve} \\= n \\+ 1\\\\)) are connected, forming\nan \\\\(n\\\\)\\-th degree spline:\n`[[float, float, float], ...], ...]`.\nThis represents anything which can be converted to a\n:class:[`Spline`](#manim.typing.Spline \"manim.typing.Spline\") NumPy array.\nPlease refer to the documentation of the function you are using for\nfurther type information.\n*class* FlatBezierPoints[¶](#manim.typing.FlatBezierPoints \"Link to this definition\")\n```\nNDArray[[PointDType](#manim.typing.PointDType \"manim.typing.PointDType\")] | tuple[float, ...]\n```\n`shape: (3*PPC*N,)`\nA flattened array of Bézier control points:\n`[float, ...]`.\n### Function types[¶](#function_types \"Link to this heading\")\n*class* FunctionOverride[¶](#manim.typing.FunctionOverride \"Link to this definition\")\n```\nCallable\n```\nFunction type returning an [`Animation`](manim.animation.animation.Animation.html#manim.animation.animation.Animation \"manim.animation.animation.Animation\") for the specified\n[`Mobject`](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\").\n*class* PathFuncType[¶](#manim.typing.PathFuncType \"Link to this definition\")\n```\nCallable[[[Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\"), float], [Point3DLike](#manim.typing.Point3DLike \"manim.typing.Point3DLike\")]\n```\nFunction mapping two :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") objects and an alpha value to a new\n:class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\").\n*class* MappingFunction[¶](#manim.typing.MappingFunction \"Link to this definition\")\n```\nCallable[[[Point3D](#manim.typing.Point3D \"manim.typing.Point3D\")], [Point3D](#manim.typing.Point3D \"manim.typing.Point3D\")]\n```\nA function mapping a :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\") to another :class:[`Point3D`](#manim.typing.Point3D \"manim.typing.Point3D\").\n*class* MultiMappingFunction[¶](#manim.typing.MultiMappingFunction \"Link to this definition\")\n```\nCallable[[[Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")], [Point3D_Array](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\")]\n```\nA function mapping a :class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\") to another\n:class:[`Point3D_Array`](#manim.typing.Point3D_Array \"manim.typing.Point3D_Array\").\n### Image types[¶](#image_types \"Link to this heading\")\n*class* PixelArray[¶](#manim.typing.PixelArray \"Link to this definition\")\n```\nNDArray[[ManimInt](#manim.typing.ManimInt \"manim.typing.ManimInt\")]\n```\n`shape: (height, width) | (height, width, 3) | (height, width, 4)`\nA rasterized image with a height of `height` pixels and a width of\n`width` pixels.\nEvery value in the array is an integer from 0 to 255\\.\nEvery pixel is represented either by a single integer indicating its\nlightness (for greyscale images), an [`RGB_Array_Int`](#manim.typing.RGB_Array_Int \"manim.typing.RGB_Array_Int\") or an\n[`RGBA_Array_Int`](#manim.typing.RGBA_Array_Int \"manim.typing.RGBA_Array_Int\").\n*class* GrayscalePixelArray[¶](#manim.typing.GrayscalePixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width)`\nA 100% opaque grayscale [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\"), where every pixel value is a\n[`ManimInt`](#manim.typing.ManimInt \"manim.typing.ManimInt\") indicating its lightness (black \\-\\> gray \\-\\> white).\n*class* RGBPixelArray[¶](#manim.typing.RGBPixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width, 3)`\nA 100% opaque [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\") in color, where every pixel value is an\n[`RGB_Array_Int`](#manim.typing.RGB_Array_Int \"manim.typing.RGB_Array_Int\") object.\n*class* RGBAPixelArray[¶](#manim.typing.RGBAPixelArray \"Link to this definition\")\n```\n[PixelArray](#manim.typing.PixelArray \"manim.typing.PixelArray\")\n```\n`shape: (height, width, 4)`\nA [`PixelArray`](#manim.typing.PixelArray \"manim.typing.PixelArray\") in color where pixels can be transparent. Every pixel\nvalue is an [`RGBA_Array_Int`](#manim.typing.RGBA_Array_Int \"manim.typing.RGBA_Array_Int\") object.\n### Path types[¶](#path_types \"Link to this heading\")\n*class* StrPath[¶](#manim.typing.StrPath \"Link to this definition\")\n```\nstr | PathLike[str]\n```\nA string or `os.PathLike` representing a path to a\ndirectory or file.\n*class* StrOrBytesPath[¶](#manim.typing.StrOrBytesPath \"Link to this definition\")\n```\nstr | bytes | PathLike[str] | PathLike[bytes]\n```\nA string, bytes or `os.PathLike` object representing a path\nto a directory or file.",
  "scraped_at": "2025-06-24T18:37:24.012800",
  "content_length": 106928,
  "domain": "docs.manim.community",
  "word_count": 9946,
  "inspection_status": "approved",
  "filename": "typing - Manim Community v0.19.0_20250624_183724.json",
  "saved_at": "2025-06-24T18:37:24.013158",
  "approved_at": "2025-06-25T17:18:58.440367"
}