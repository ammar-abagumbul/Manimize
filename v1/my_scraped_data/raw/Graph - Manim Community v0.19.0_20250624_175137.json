{
  "doc_id": "da996a11adc0ab2ee5270f01d3342e84",
  "url": "https://docs.manim.community/en/latest/reference/manim.mobject.graph.Graph.html",
  "title": "Graph - Manim Community v0.19.0",
  "content": "Graph[¶](#graph \"Link to this heading\")\n=======================================\nQualified name: `manim.mobject.graph.Graph`\n*class* Graph(*vertices*, *edges*, *labels\\=False*, *label\\_fill\\_color\\=ManimColor('\\#000000')*, *layout\\='spring'*, *layout\\_scale\\=2*, *layout\\_config\\=None*, *vertex\\_type\\=\\<class 'manim.mobject.geometry.arc.Dot'\\>*, *vertex\\_config\\=None*, *vertex\\_mobjects\\=None*, *edge\\_type\\=\\<class 'manim.mobject.geometry.line.Line'\\>*, *partitions\\=None*, *root\\_vertex\\=None*, *edge\\_config\\=None*)[\\[source]](../_modules/manim/mobject/graph.html#Graph)[¶](#manim.mobject.graph.Graph \"Link to this definition\")\nBases: [`GenericGraph`](manim.mobject.graph.GenericGraph.html#manim.mobject.graph.GenericGraph \"manim.mobject.graph.GenericGraph\")\nAn undirected graph (vertices connected with edges).\nThe graph comes with an updater which makes the edges stick to\nthe vertices when moved around. See [`DiGraph`](manim.mobject.graph.DiGraph.html#manim.mobject.graph.DiGraph \"manim.mobject.graph.DiGraph\") for\na version with directed edges.\nSee also\n[`GenericGraph`](manim.mobject.graph.GenericGraph.html#manim.mobject.graph.GenericGraph \"manim.mobject.graph.GenericGraph\")\nParameters:\n* **vertices** (*Sequence**\\[**Hashable**]*) – A list of vertices. Must be hashable elements.\n* **edges** (*Sequence**\\[**tuple**\\[**Hashable**,* *Hashable**]**]*) – A list of edges, specified as tuples `(u, v)` where both `u`\nand `v` are vertices. The vertex order is irrelevant.\n* **labels** (*bool* *\\|* *dict*) – Controls whether or not vertices are labeled. If `False` (the default),\nthe vertices are not labeled; if `True` they are labeled using their\nnames (as specified in `vertices`) via [`MathTex`](manim.mobject.text.tex_mobject.MathTex.html#manim.mobject.text.tex_mobject.MathTex \"manim.mobject.text.tex_mobject.MathTex\"). Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., [`Text`](manim.mobject.text.text_mobject.Text.html#manim.mobject.text.text_mobject.Text \"manim.mobject.text.text_mobject.Text\") or [`Tex`](manim.mobject.text.tex_mobject.Tex.html#manim.mobject.text.tex_mobject.Tex \"manim.mobject.text.tex_mobject.Tex\")).\n* **label\\_fill\\_color** (*str*) – Sets the fill color of the default labels generated when `labels`\nis set to `True`. Has no effect for other values of `labels`.\n* **layout** (*LayoutName* *\\|* *dict**\\[**Hashable**,* [*Point3DLike*](manim.typing.html#manim.typing.Point3DLike \"manim.typing.Point3DLike\")*]* *\\|* [*LayoutFunction*](manim.mobject.graph.LayoutFunction.html#manim.mobject.graph.LayoutFunction \"manim.mobject.graph.LayoutFunction\")) – Either one of `\"spring\"` (the default), `\"circular\"`, `\"kamada_kawai\"`,\n`\"planar\"`, `\"random\"`, `\"shell\"`, `\"spectral\"`, `\"spiral\"`, `\"tree\"`, and `\"partite\"`\nfor automatic vertex positioning using `networkx`\n(see [their documentation](https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout)\nfor more details), or a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning.\n* **layout\\_config** (*dict* *\\|* *None*) – Only for automatically generated layouts. A dictionary whose entries\nare passed as keyword arguments to the automatic layout algorithm\nspecified via `layout` of `networkx`.\nThe `tree` layout also accepts a special parameter `vertex_spacing`\npassed as a keyword argument inside the `layout_config` dictionary.\nPassing a tuple `(space_x, space_y)` as this argument overrides\nthe value of `layout_scale` and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least `space_x` units apart horizontally, and neighboring layers\nare spaced `space_y` units vertically.\n* **layout\\_scale** (*float* *\\|* *tuple**\\[**float**,* *float**,* *float**]*) – The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval `[-scale, scale]`. Some layouts accept a tuple `(scale_x, scale_y)`\ncausing the first coordinate to be in the interval `[-scale_x, scale_x]`,\nand the second in `[-scale_y, scale_y]`. Default: 2\\.\n* **vertex\\_type** (*type**\\[*[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]*) – The mobject class used for displaying vertices in the scene.\n* **vertex\\_config** (*dict* *\\|* *None*) – Either a dictionary containing keyword arguments to be passed to\nthe class specified via `vertex_type`, or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex.\n* **vertex\\_mobjects** (*dict* *\\|* *None*) – A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex.\n* **edge\\_type** (*type**\\[*[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]*) – The mobject class used for displaying edges in the scene.\n* **edge\\_config** (*dict* *\\|* *None*) – Either a dictionary containing keyword arguments to be passed\nto the class specified via `edge_type`, or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge.\n* **partitions** (*Sequence**\\[**Sequence**\\[**Hashable**]**]* *\\|* *None*)\n* **root\\_vertex** (*Hashable* *\\|* *None*)\nExamples\nFirst, we create a small graph and demonstrate that the edges move\ntogether with the vertices.\nExample: MovingVertices [¶](#movingvertices)\n```\nfrom manim import *\nclass MovingVertices(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n        g = Graph(vertices, edges)\n        self.play(Create(g))\n        self.wait()\n        self.play(g[1].animate.move_to([1, 1, 0]),\n                  g[2].animate.move_to([-1, 1, 0]),\n                  g[3].animate.move_to([1, -1, 0]),\n                  g[4].animate.move_to([-1, -1, 0]))\n        self.wait()\n```\n```\nclass MovingVertices(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n        g = Graph(vertices, edges)\n        self.play(Create(g))\n        self.wait()\n        self.play(g[1].animate.move_to([1, 1, 0]),\n                  g[2].animate.move_to([-1, 1, 0]),\n                  g[3].animate.move_to([1, -1, 0]),\n                  g[4].animate.move_to([-1, -1, 0]))\n        self.wait()\n```\nThere are several automatic positioning algorithms to choose from:\nExample: GraphAutoPosition [¶](#graphautoposition)\n![../_images/GraphAutoPosition-1.png](../_images/GraphAutoPosition-1.png)\n```\nfrom manim import *\nclass GraphAutoPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                       \"planar\", \"random\", \"shell\",\n                       \"spectral\", \"spiral\"]\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                  for lt in autolayouts]\n        r1 = VGroup(*graphs[:3]).arrange()\n        r2 = VGroup(*graphs[3:6]).arrange()\n        r3 = VGroup(*graphs[6:]).arrange()\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))\n```\n```\nclass GraphAutoPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                       \"planar\", \"random\", \"shell\",\n                       \"spectral\", \"spiral\"]\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                  for lt in autolayouts]\n        r1 = VGroup(*graphs[:3]).arrange()\n        r2 = VGroup(*graphs[3:6]).arrange()\n        r3 = VGroup(*graphs[6:]).arrange()\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))\n```\nVertices can also be positioned manually:\nExample: GraphManualPosition [¶](#graphmanualposition)\n![../_images/GraphManualPosition-1.png](../_images/GraphManualPosition-1.png)\n```\nfrom manim import *\nclass GraphManualPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n        G = Graph(vertices, edges, layout=lt)\n        self.add(G)\n```\n```\nclass GraphManualPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n        G = Graph(vertices, edges, layout=lt)\n        self.add(G)\n```\nThe vertices in graphs can be labeled, and configurations for vertices\nand edges can be modified both by default and for specific vertices and\nedges.\nNote\nIn `edge_config`, edges can be passed in both directions: if\n`(u, v)` is an edge in the graph, both `(u, v)` as well\nas `(v, u)` can be used as keys in the dictionary.\nExample: LabeledModifiedGraph [¶](#labeledmodifiedgraph)\n![../_images/LabeledModifiedGraph-1.png](../_images/LabeledModifiedGraph-1.png)\n```\nfrom manim import *\nclass LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g)\n```\n```\nclass LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g)\n```\nYou can also lay out a partite graph on columns by specifying\na list of the vertices on each side and choosing the partite layout.\nNote\nAll vertices in your graph which are not listed in any of the partitions\nare collected in their own partition and rendered in the rightmost column.\nExample: PartiteGraph [¶](#partitegraph)\n![../_images/PartiteGraph-1.png](../_images/PartiteGraph-1.png)\n```\nfrom manim import *\nimport networkx as nx\nclass PartiteGraph(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_nodes_from([0, 1, 2, 3])\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n        self.play(Create(graph))\n```\n```\nimport networkx as nx\nclass PartiteGraph(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_nodes_from([0, 1, 2, 3])\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n        self.play(Create(graph))\n```\nThe representation of a linear artificial neural network is facilitated\nby the use of the partite layout and defining partitions for each layer.\nExample: LinearNN [¶](#linearnn)\n![../_images/LinearNN-1.png](../_images/LinearNN-1.png)\n```\nfrom manim import *\nclass LinearNN(Scene):\n    def construct(self):\n        edges = []\n        partitions = []\n        c = 0\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\n        for i in layers:\n            partitions.append(list(range(c + 1, c + i + 1)))\n            c += i\n        for i, v in enumerate(layers[1:]):\n                last = sum(layers[:i+1])\n                for j in range(v):\n                    for k in range(last - layers[i], last):\n                        edges.append((k + 1, j + last + 1))\n        vertices = np.arange(1, sum(layers) + 1)\n        graph = Graph(\n            vertices,\n            edges,\n            layout='partite',\n            partitions=partitions,\n            layout_scale=3,\n            vertex_config={'radius': 0.20},\n        )\n        self.add(graph)\n```\n```\nclass LinearNN(Scene):\n    def construct(self):\n        edges = []\n        partitions = []\n        c = 0\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\n        for i in layers:\n            partitions.append(list(range(c + 1, c + i + 1)))\n            c += i\n        for i, v in enumerate(layers[1:]):\n                last = sum(layers[:i+1])\n                for j in range(v):\n                    for k in range(last - layers[i], last):\n                        edges.append((k + 1, j + last + 1))\n        vertices = np.arange(1, sum(layers) + 1)\n        graph = Graph(\n            vertices,\n            edges,\n            layout='partite',\n            partitions=partitions,\n            layout_scale=3,\n            vertex_config={'radius': 0.20},\n        )\n        self.add(graph)\n```\nThe custom tree layout can be used to show the graph\nby distance from the root vertex. You must pass the root vertex\nof the tree.\nExample: Tree [¶](#tree)\n```\nfrom manim import *\nimport networkx as nx\nclass Tree(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_node(\"ROOT\")\n        for i in range(5):\n            G.add_node(\"Child_%i\" % i)\n            G.add_node(\"Grandchild_%i\" % i)\n            G.add_node(\"Greatgrandchild_%i\" % i)\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n        self.play(Create(\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))\n```\n```\nimport networkx as nx\nclass Tree(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_node(\"ROOT\")\n        for i in range(5):\n            G.add_node(\"Child_%i\" % i)\n            G.add_node(\"Grandchild_%i\" % i)\n            G.add_node(\"Greatgrandchild_%i\" % i)\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n        self.play(Create(\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))\n```\nThe following code sample illustrates the use of the `vertex_spacing`\nlayout parameter specific to the `\"tree\"` layout. As mentioned\nabove, setting `vertex_spacing` overrides the specified value\nfor `layout_scale`, and as such it is harder to control the size\nof the mobject. However, we can adjust the captured frame and\nzoom out by using a [`MovingCameraScene`](manim.scene.moving_camera_scene.MovingCameraScene.html#manim.scene.moving_camera_scene.MovingCameraScene \"manim.scene.moving_camera_scene.MovingCameraScene\"):\n```\nclass LargeTreeGeneration(MovingCameraScene):\n    DEPTH = 4\n    CHILDREN_PER_VERTEX = 3\n    LAYOUT_CONFIG = {\"vertex_spacing\": (0.5, 1)}\n    VERTEX_CONF = {\"radius\": 0.25, \"color\": BLUE_B, \"fill_opacity\": 1}\n    def expand_vertex(self, g, vertex_id: str, depth: int):\n        new_vertices = [\n            f\"{vertex_id}/{i}\" for i in range(self.CHILDREN_PER_VERTEX)\n        ]\n        new_edges = [(vertex_id, child_id) for child_id in new_vertices]\n        g.add_edges(\n            *new_edges,\n            vertex_config=self.VERTEX_CONF,\n            positions={\n                k: g.vertices[vertex_id].get_center() + 0.1 * DOWN\n                for k in new_vertices\n            },\n        )\n        if depth < self.DEPTH:\n            for child_id in new_vertices:\n                self.expand_vertex(g, child_id, depth + 1)\n        return g\n    def construct(self):\n        g = Graph([\"ROOT\"], [], vertex_config=self.VERTEX_CONF)\n        g = self.expand_vertex(g, \"ROOT\", 1)\n        self.add(g)\n        self.play(\n            g.animate.change_layout(\n                \"tree\",\n                root_vertex=\"ROOT\",\n                layout_config=self.LAYOUT_CONFIG,\n            )\n        )\n        self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)\n```\nMethods\n| `update_edges` |  |\n| --- | --- |\nAttributes\n| `animate` | Used to animate the application of any method of `self`. |\n| --- | --- |\n| `animation_overrides` |  |\n| `color` |  |\n| `depth` | The depth of the mobject. |\n| `fill_color` | If there are multiple colors (for gradient) this returns the first one |\n| `height` | The height of the mobject. |\n| `n_points_per_curve` |  |\n| `sheen_factor` |  |\n| `stroke_color` |  |\n| `width` | The width of the mobject. |\n*static* \\_empty\\_networkx\\_graph()[\\[source]](../_modules/manim/mobject/graph.html#Graph._empty_networkx_graph)[¶](#manim.mobject.graph.Graph._empty_networkx_graph \"Link to this definition\")\nReturn an empty networkx graph for the given graph type.\nReturn type:\n*Graph*\n\\_original\\_\\_init\\_\\_(*vertices*, *edges*, *labels\\=False*, *label\\_fill\\_color\\=ManimColor('\\#000000')*, *layout\\='spring'*, *layout\\_scale\\=2*, *layout\\_config\\=None*, *vertex\\_type\\=\\<class 'manim.mobject.geometry.arc.Dot'\\>*, *vertex\\_config\\=None*, *vertex\\_mobjects\\=None*, *edge\\_type\\=\\<class 'manim.mobject.geometry.line.Line'\\>*, *partitions\\=None*, *root\\_vertex\\=None*, *edge\\_config\\=None*)[¶](#manim.mobject.graph.Graph._original__init__ \"Link to this definition\")\nInitialize self. See help(type(self)) for accurate signature.\nParameters:\n* **vertices** (*Sequence**\\[**Hashable**]*)\n* **edges** (*Sequence**\\[**tuple**\\[**Hashable**,* *Hashable**]**]*)\n* **labels** (*bool* *\\|* *dict*)\n* **label\\_fill\\_color** (*str*)\n* **layout** (*Literal**\\[**'circular'**,* *'kamada\\_kawai'**,* *'partite'**,* *'planar'**,* *'random'**,* *'shell'**,* *'spectral'**,* *'spiral'**,* *'spring'**,* *'tree'**]* *\\|* *dict**\\[**\\~collections.abc.Hashable**,* *TypeAliasForwardRef**(**'\\~manim.typing.Point3DLike'**)**]* *\\|* *\\~manim.mobject.graph.LayoutFunction*)\n* **layout\\_scale** (*float* *\\|* *tuple**\\[**float**,* *float**,* *float**]*)\n* **layout\\_config** (*dict* *\\|* *None*)\n* **vertex\\_type** (*type**\\[*[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]*)\n* **vertex\\_config** (*dict* *\\|* *None*)\n* **vertex\\_mobjects** (*dict* *\\|* *None*)\n* **edge\\_type** (*type**\\[*[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]*)\n* **partitions** (*Sequence**\\[**Sequence**\\[**Hashable**]**]* *\\|* *None*)\n* **root\\_vertex** (*Hashable* *\\|* *None*)\n* **edge\\_config** (*dict* *\\|* *None*)\nReturn type:\nNone\n\\_populate\\_edge\\_dict(*edges*, *edge\\_type*)[\\[source]](../_modules/manim/mobject/graph.html#Graph._populate_edge_dict)[¶](#manim.mobject.graph.Graph._populate_edge_dict \"Link to this definition\")\nHelper method for populating the edges of the graph.\nParameters:\n* **edges** (*list**\\[**tuple**\\[**Hashable**,* *Hashable**]**]*)\n* **edge\\_type** (*type**\\[*[*Mobject*](manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject \"manim.mobject.mobject.Mobject\")*]*)",
  "scraped_at": "2025-06-24T17:51:37.307880",
  "content_length": 19732,
  "domain": "docs.manim.community",
  "word_count": 2008,
  "inspection_status": "pending",
  "filename": "Graph - Manim Community v0.19.0_20250624_175137.json",
  "saved_at": "2025-06-24T17:51:37.308077"
}