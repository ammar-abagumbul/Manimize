{
  "doc_id": "583bd53615a6ed66d00a5f3ef26c8097",
  "url": "https://docs.manim.community/en/latest/reference/manim.mobject.graph.LayoutFunction.html",
  "title": "LayoutFunction - Manim Community v0.19.0",
  "content": "LayoutFunction[¶](#layoutfunction \"Link to this heading\")\n=========================================================\nQualified name: `manim.mobject.graph.LayoutFunction`\n*class* LayoutFunction(*\\*args*, *\\*\\*kwargs*)[\\[source]](../_modules/manim/mobject/graph.html#LayoutFunction)[¶](#manim.mobject.graph.LayoutFunction \"Link to this definition\")\nBases: `Protocol`\nA protocol for automatic layout functions that compute a layout for a graph to be used in `change_layout()`.\nNote\nThe layout function must be a pure function, i.e., it must not modify the graph passed to it.\nExamples\nHere is an example that arranges nodes in an n x m grid in sorted order.\nExample: CustomLayoutExample [¶](#customlayoutexample)\n![../_images/CustomLayoutExample-1.png](../_images/CustomLayoutExample-1.png)\n```\nfrom manim import *\nclass CustomLayoutExample(Scene):\n    def construct(self):\n        import numpy as np\n        import networkx as nx\n        # create custom layout\n        def custom_layout(\n            graph: nx.Graph,\n            scale: float | tuple[float, float, float] = 2,\n            n: int | None = None,\n            *args: Any,\n            **kwargs: Any,\n        ):\n            nodes = sorted(list(graph))\n            height = len(nodes) // n\n            return {\n                node: (scale * np.array([\n                    (i % n) - (n-1)/2,\n                    -(i // n) + height/2,\n                    0\n                ])) for i, node in enumerate(graph)\n            }\n        # draw graph\n        n = 4\n        graph = Graph(\n            [i for i in range(4 * 2 - 1)],\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n            labels=True,\n            layout=custom_layout,\n            layout_config={'n': n}\n        )\n        self.add(graph)\n```\n```\nclass CustomLayoutExample(Scene):\n    def construct(self):\n        import numpy as np\n        import networkx as nx\n        # create custom layout\n        def custom_layout(\n            graph: nx.Graph,\n            scale: float | tuple[float, float, float] = 2,\n            n: int | None = None,\n            *args: Any,\n            **kwargs: Any,\n        ):\n            nodes = sorted(list(graph))\n            height = len(nodes) // n\n            return {\n                node: (scale * np.array([\n                    (i % n) - (n-1)/2,\n                    -(i // n) + height/2,\n                    0\n                ])) for i, node in enumerate(graph)\n            }\n        # draw graph\n        n = 4\n        graph = Graph(\n            [i for i in range(4 * 2 - 1)],\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n            labels=True,\n            layout=custom_layout,\n            layout_config={'n': n}\n        )\n        self.add(graph)\n```\nSeveral automatic layouts are provided by manim, and can be used by passing their name as the `layout` parameter to `change_layout()`.\nAlternatively, a custom layout function can be passed to `change_layout()` as the `layout` parameter. Such a function must adhere to the [`LayoutFunction`](#manim.mobject.graph.LayoutFunction \"manim.mobject.graph.LayoutFunction\") protocol.\nThe [`LayoutFunction`](#manim.mobject.graph.LayoutFunction \"manim.mobject.graph.LayoutFunction\") s provided by manim are illustrated below:\n* Circular Layout: places the vertices on a circle\nExample: CircularLayout [¶](#circularlayout)\n![../_images/CircularLayout-1.png](../_images/CircularLayout-1.png)\n```\nfrom manim import *\nclass CircularLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"circular\",\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass CircularLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"circular\",\n            labels=True\n        )\n        self.add(graph)\n```\n* Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected\nExample: KamadaKawaiLayout [¶](#kamadakawailayout)\n![../_images/KamadaKawaiLayout-1.png](../_images/KamadaKawaiLayout-1.png)\n```\nfrom manim import *\nclass KamadaKawaiLayout(Scene):\n    def construct(self):\n        from collections import defaultdict\n        distances: dict[int, dict[int, float]] = defaultdict(dict)\n        # set desired distances\n        distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n        distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n        distances[3][4] = 2  # etc\n        distances[4][5] = 3\n        distances[5][6] = 5\n        distances[6][1] = 8\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n            layout=\"kamada_kawai\",\n            layout_config={\"dist\": distances},\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass KamadaKawaiLayout(Scene):\n    def construct(self):\n        from collections import defaultdict\n        distances: dict[int, dict[int, float]] = defaultdict(dict)\n        # set desired distances\n        distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n        distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n        distances[3][4] = 2  # etc\n        distances[4][5] = 3\n        distances[5][6] = 5\n        distances[6][1] = 8\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n            layout=\"kamada_kawai\",\n            layout_config={\"dist\": distances},\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)\n```\n* Partite Layout: places vertices into distinct partitions\nExample: PartiteLayout [¶](#partitelayout)\n![../_images/PartiteLayout-1.png](../_images/PartiteLayout-1.png)\n```\nfrom manim import *\nclass PartiteLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"partite\",\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass PartiteLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"partite\",\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n            labels=True\n        )\n        self.add(graph)\n```\n* Planar Layout: places vertices such that edges do not cross\nExample: PlanarLayout [¶](#planarlayout)\n![../_images/PlanarLayout-1.png](../_images/PlanarLayout-1.png)\n```\nfrom manim import *\nclass PlanarLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"planar\",\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass PlanarLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"planar\",\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)\n```\n* Random Layout: randomly places vertices\nExample: RandomLayout [¶](#randomlayout)\n![../_images/RandomLayout-1.png](../_images/RandomLayout-1.png)\n```\nfrom manim import *\nclass RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph)\n```\n* Shell Layout: places vertices in concentric circles\nExample: ShellLayout [¶](#shelllayout)\n![../_images/ShellLayout-1.png](../_images/ShellLayout-1.png)\n```\nfrom manim import *\nclass ShellLayout(Scene):\n    def construct(self):\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n            layout=\"shell\",\n            layout_config={\"nlist\": nlist},\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass ShellLayout(Scene):\n    def construct(self):\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n            layout=\"shell\",\n            layout_config={\"nlist\": nlist},\n            labels=True\n        )\n        self.add(graph)\n```\n* Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut)\nExample: SpectralLayout [¶](#spectrallayout)\n![../_images/SpectralLayout-1.png](../_images/SpectralLayout-1.png)\n```\nfrom manim import *\nclass SpectralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spectral\",\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass SpectralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spectral\",\n            labels=True\n        )\n        self.add(graph)\n```\n* Sprial Layout: places vertices in a spiraling pattern\nExample: SpiralLayout [¶](#spirallayout)\n![../_images/SpiralLayout-1.png](../_images/SpiralLayout-1.png)\n```\nfrom manim import *\nclass SpiralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spiral\",\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass SpiralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spiral\",\n            labels=True\n        )\n        self.add(graph)\n```\n* Spring Layout: places nodes according to the Fruchterman\\-Reingold force\\-directed algorithm (attempts to minimize edge length while maximizing node separation)\nExample: SpringLayout [¶](#springlayout)\n![../_images/SpringLayout-1.png](../_images/SpringLayout-1.png)\n```\nfrom manim import *\nclass SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph)\n```\n* Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees)\nExample: TreeLayout [¶](#treelayout)\n![../_images/TreeLayout-1.png](../_images/TreeLayout-1.png)\n```\nfrom manim import *\nclass TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph)\n```\n```\nclass TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph)\n```\nMethods",
  "scraped_at": "2025-06-24T17:51:39.839124",
  "content_length": 12595,
  "domain": "docs.manim.community",
  "word_count": 1456,
  "inspection_status": "pending",
  "filename": "LayoutFunction - Manim Community v0.19.0_20250624_175139.json",
  "saved_at": "2025-06-24T17:51:39.839244"
}