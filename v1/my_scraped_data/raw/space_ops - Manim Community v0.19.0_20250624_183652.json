{
  "doc_id": "24ff8dc7f3823a324b15f11bf3125a7e",
  "url": "https://docs.manim.community/en/latest/reference/manim.utils.space_ops.html",
  "title": "space_ops - Manim Community v0.19.0",
  "content": "space\\_ops[¶](#module-manim.utils.space_ops \"Link to this heading\")\n===================================================================\nUtility functions for two\\- and three\\-dimensional vectors.\nFunctions\nR3\\_to\\_complex(*point*)[\\[source]](../_modules/manim/utils/space_ops.html#R3_to_complex)[¶](#manim.utils.space_ops.R3_to_complex \"Link to this definition\")\nParameters:\n**point** (*Sequence**\\[**float**]*)\nReturn type:\n*ndarray*\nangle\\_axis\\_from\\_quaternion(*quaternion*)[\\[source]](../_modules/manim/utils/space_ops.html#angle_axis_from_quaternion)[¶](#manim.utils.space_ops.angle_axis_from_quaternion \"Link to this definition\")\nGets angle and axis from a quaternion.\nParameters:\n**quaternion** (*Sequence**\\[**float**]*) – The quaternion from which we get the angle and axis.\nReturns:\nGives the angle and axis\nReturn type:\nSequence\\[float]\nangle\\_between\\_vectors(*v1*, *v2*)[\\[source]](../_modules/manim/utils/space_ops.html#angle_between_vectors)[¶](#manim.utils.space_ops.angle_between_vectors \"Link to this definition\")\nReturns the angle between two vectors.\nThis angle will always be between 0 and pi\nParameters:\n* **v1** (*ndarray*) – The first vector.\n* **v2** (*ndarray*) – The second vector.\nReturns:\nThe angle between the vectors.\nReturn type:\nfloat\nangle\\_of\\_vector(*vector*)[\\[source]](../_modules/manim/utils/space_ops.html#angle_of_vector)[¶](#manim.utils.space_ops.angle_of_vector \"Link to this definition\")\nReturns polar coordinate theta when vector is projected on xy plane.\nParameters:\n**vector** (*Sequence**\\[**float**]* *\\|* *ndarray*) – The vector to find the angle for.\nReturns:\nThe angle of the vector projected.\nReturn type:\nfloat\ncartesian\\_to\\_spherical(*vec*)[\\[source]](../_modules/manim/utils/space_ops.html#cartesian_to_spherical)[¶](#manim.utils.space_ops.cartesian_to_spherical \"Link to this definition\")\nReturns an array of numbers corresponding to each\npolar coordinate value (distance, phi, theta).\nParameters:\n**vec** (*Sequence**\\[**float**]*) – A numpy array `[x, y, z]`.\nReturn type:\n*ndarray*\ncenter\\_of\\_mass(*points*)[\\[source]](../_modules/manim/utils/space_ops.html#center_of_mass)[¶](#manim.utils.space_ops.center_of_mass \"Link to this definition\")\nGets the center of mass of the points in space.\nParameters:\n**points** ([*PointNDLike\\_Array*](manim.typing.html#manim.typing.PointNDLike_Array \"manim.typing.PointNDLike_Array\")) – The points to find the center of mass from.\nReturns:\nThe center of mass of the points.\nReturn type:\nnp.ndarray\ncompass\\_directions(*n\\=4*, *start\\_vect\\=array(\\[1\\., 0\\., 0\\.])*)[\\[source]](../_modules/manim/utils/space_ops.html#compass_directions)[¶](#manim.utils.space_ops.compass_directions \"Link to this definition\")\nFinds the cardinal directions using tau.\nParameters:\n* **n** (*int*) – The amount to be rotated, by default 4\n* **start\\_vect** (*ndarray*) – The direction for the angle to start with, by default RIGHT\nReturns:\nThe angle which has been rotated.\nReturn type:\nnp.ndarray\ncomplex\\_func\\_to\\_R3\\_func(*complex\\_func*)[\\[source]](../_modules/manim/utils/space_ops.html#complex_func_to_R3_func)[¶](#manim.utils.space_ops.complex_func_to_R3_func \"Link to this definition\")\nParameters:\n**complex\\_func** (*Callable**\\[**\\[**complex**]**,* *complex**]*)\nReturn type:\n*Callable*\\[\\[TypeAliasForwardRef(‘\\~manim.typing.Point3DLike’)], TypeAliasForwardRef(‘\\~manim.typing.Point3D’)]\ncomplex\\_to\\_R3(*complex\\_num*)[\\[source]](../_modules/manim/utils/space_ops.html#complex_to_R3)[¶](#manim.utils.space_ops.complex_to_R3 \"Link to this definition\")\nParameters:\n**complex\\_num** (*complex*)\nReturn type:\n*ndarray*\ncross(*v1*, *v2*)[\\[source]](../_modules/manim/utils/space_ops.html#cross)[¶](#manim.utils.space_ops.cross \"Link to this definition\")\nParameters:\n* **v1** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\"))\n* **v2** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\"))\nReturn type:\n[*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")\ncross2d(*a*, *b*)[\\[source]](../_modules/manim/utils/space_ops.html#cross2d)[¶](#manim.utils.space_ops.cross2d \"Link to this definition\")\nCompute the determinant(s) of the passed\nvector (sequences).\nParameters:\n* **a** ([*Vector2D*](manim.typing.html#manim.typing.Vector2D \"manim.typing.Vector2D\") *\\|* [*Vector2D\\_Array*](manim.typing.html#manim.typing.Vector2D_Array \"manim.typing.Vector2D_Array\")) – A vector or a sequence of vectors.\n* **b** ([*Vector2D*](manim.typing.html#manim.typing.Vector2D \"manim.typing.Vector2D\") *\\|* [*Vector2D\\_Array*](manim.typing.html#manim.typing.Vector2D_Array \"manim.typing.Vector2D_Array\")) – A vector or a sequence of vectors.\nReturns:\nThe determinant or sequence of determinants\nof the first two components of the specified\nvectors.\nReturn type:\nSequence\\[float] \\| float\nExamples\n```\n>>> cross2d(np.array([1, 2]), np.array([3, 4]))\nnp.int64(-2)\n>>> cross2d(\n...     np.array([[1, 2, 0], [1, 0, 0]]),\n...     np.array([[3, 4, 0], [0, 1, 0]]),\n... )\narray([-2,  1])\n```\nearclip\\_triangulation(*verts*, *ring\\_ends*)[\\[source]](../_modules/manim/utils/space_ops.html#earclip_triangulation)[¶](#manim.utils.space_ops.earclip_triangulation \"Link to this definition\")\nReturns a list of indices giving a triangulation\nof a polygon, potentially with holes.\nParameters:\n* **verts** (*ndarray*) – verts is a numpy array of points.\n* **ring\\_ends** (*list*) – ring\\_ends is a list of indices indicating where\nthe ends of new paths are.\nReturns:\nA list of indices giving a triangulation of a polygon.\nReturn type:\nlist\nfind\\_intersection(*p0s*, *v0s*, *p1s*, *v1s*, *threshold\\=1e\\-05*)[\\[source]](../_modules/manim/utils/space_ops.html#find_intersection)[¶](#manim.utils.space_ops.find_intersection \"Link to this definition\")\nReturn the intersection of a line passing through p0 in direction v0\nwith one passing through p1 in direction v1 (or array of intersections\nfrom arrays of such points/directions).\nFor 3d values, it returns the point on the ray p0 \\+ v0 \\* t closest to the\nray p1 \\+ v1 \\* t\nParameters:\n* **p0s** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\"))\n* **v0s** ([*Vector3D\\_Array*](manim.typing.html#manim.typing.Vector3D_Array \"manim.typing.Vector3D_Array\"))\n* **p1s** ([*Point3DLike\\_Array*](manim.typing.html#manim.typing.Point3DLike_Array \"manim.typing.Point3DLike_Array\"))\n* **v1s** ([*Vector3D\\_Array*](manim.typing.html#manim.typing.Vector3D_Array \"manim.typing.Vector3D_Array\"))\n* **threshold** (*float*)\nReturn type:\nlist\\[TypeAliasForwardRef(‘\\~manim.typing.Point3D’)]\nget\\_unit\\_normal(*v1*, *v2*, *tol\\=1e\\-06*)[\\[source]](../_modules/manim/utils/space_ops.html#get_unit_normal)[¶](#manim.utils.space_ops.get_unit_normal \"Link to this definition\")\nGets the unit normal of the vectors.\nParameters:\n* **v1** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")) – The first vector.\n* **v2** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")) – The second vector\n* **tol** (*float*) – \\[description], by default 1e\\-6\nReturns:\nThe normal of the two vectors.\nReturn type:\nnp.ndarray\nget\\_winding\\_number(*points*)[\\[source]](../_modules/manim/utils/space_ops.html#get_winding_number)[¶](#manim.utils.space_ops.get_winding_number \"Link to this definition\")\nDetermine the number of times a polygon winds around the origin.\nThe orientation is measured mathematically positively, i.e.,\ncounterclockwise.\nParameters:\n**points** (*Sequence**\\[**ndarray**]*) – The vertices of the polygon being queried.\nReturn type:\nfloat\nExamples\n```\n>>> from manim import Square, get_winding_number\n>>> polygon = Square()\n>>> get_winding_number(polygon.get_vertices())\nnp.float64(1.0)\n>>> polygon.shift(2 * UP)\nSquare\n>>> get_winding_number(polygon.get_vertices())\nnp.float64(0.0)\n```\nline\\_intersection(*line1*, *line2*)[\\[source]](../_modules/manim/utils/space_ops.html#line_intersection)[¶](#manim.utils.space_ops.line_intersection \"Link to this definition\")\nReturns the intersection point of two lines, each defined by\na pair of distinct points lying on the line.\nParameters:\n* **line1** (*Sequence**\\[**ndarray**]*) – A list of two points that determine the first line.\n* **line2** (*Sequence**\\[**ndarray**]*) – A list of two points that determine the second line.\nReturns:\nThe intersection points of the two lines which are intersecting.\nReturn type:\nnp.ndarray\nRaises:\n**ValueError** – Error is produced if the two lines don’t intersect with each other\n or if the coordinates don’t lie on the xy\\-plane.\nmidpoint(*point1*, *point2*)[\\[source]](../_modules/manim/utils/space_ops.html#midpoint)[¶](#manim.utils.space_ops.midpoint \"Link to this definition\")\nGets the midpoint of two points.\nParameters:\n* **point1** (*Sequence**\\[**float**]*) – The first point.\n* **point2** (*Sequence**\\[**float**]*) – The second point.\nReturns:\nThe midpoint of the points\nReturn type:\n[Union](manim.mobject.geometry.boolean_ops.Union.html#manim.mobject.geometry.boolean_ops.Union \"manim.mobject.geometry.boolean_ops.Union\")\\[float, np.ndarray]\nnorm\\_squared(*v*)[\\[source]](../_modules/manim/utils/space_ops.html#norm_squared)[¶](#manim.utils.space_ops.norm_squared \"Link to this definition\")\nParameters:\n**v** (*float*)\nReturn type:\nfloat\nnormalize(*vect*, *fall\\_back\\=None*)[\\[source]](../_modules/manim/utils/space_ops.html#normalize)[¶](#manim.utils.space_ops.normalize \"Link to this definition\")\nParameters:\n* **vect** (*ndarray* *\\|* *tuple**\\[**float**]*)\n* **fall\\_back** (*ndarray* *\\|* *None*)\nReturn type:\n*ndarray*\nnormalize\\_along\\_axis(*array*, *axis*)[\\[source]](../_modules/manim/utils/space_ops.html#normalize_along_axis)[¶](#manim.utils.space_ops.normalize_along_axis \"Link to this definition\")\nNormalizes an array with the provided axis.\nParameters:\n* **array** (*ndarray*) – The array which has to be normalized.\n* **axis** (*ndarray*) – The axis to be normalized to.\nReturns:\nArray which has been normalized according to the axis.\nReturn type:\nnp.ndarray\nperpendicular\\_bisector(*line*, *norm\\_vector\\=array(\\[0\\., 0\\., 1\\.])*)[\\[source]](../_modules/manim/utils/space_ops.html#perpendicular_bisector)[¶](#manim.utils.space_ops.perpendicular_bisector \"Link to this definition\")\nReturns a list of two points that correspond\nto the ends of the perpendicular bisector of the\ntwo points given.\nParameters:\n* **line** (*Sequence**\\[**ndarray**]*) – a list of two numpy array points (corresponding\nto the ends of a line).\n* **norm\\_vector** ([*Vector3D*](manim.typing.html#manim.typing.Vector3D \"manim.typing.Vector3D\")) – the vector perpendicular to both the line given\nand the perpendicular bisector.\nReturns:\nA list of two numpy array points that correspond\nto the ends of the perpendicular bisector\nReturn type:\nlist\nquaternion\\_conjugate(*quaternion*)[\\[source]](../_modules/manim/utils/space_ops.html#quaternion_conjugate)[¶](#manim.utils.space_ops.quaternion_conjugate \"Link to this definition\")\nUsed for finding the conjugate of the quaternion\nParameters:\n**quaternion** (*Sequence**\\[**float**]*) – The quaternion for which you want to find the conjugate for.\nReturns:\nThe conjugate of the quaternion.\nReturn type:\nnp.ndarray\nquaternion\\_from\\_angle\\_axis(*angle*, *axis*, *axis\\_normalized\\=False*)[\\[source]](../_modules/manim/utils/space_ops.html#quaternion_from_angle_axis)[¶](#manim.utils.space_ops.quaternion_from_angle_axis \"Link to this definition\")\nGets a quaternion from an angle and an axis.\nFor more information, check [this Wikipedia page](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles).\nParameters:\n* **angle** (*float*) – The angle for the quaternion.\n* **axis** (*ndarray*) – The axis for the quaternion\n* **axis\\_normalized** (*bool*) – Checks whether the axis is normalized, by default False\nReturns:\nGives back a quaternion from the angle and axis\nReturn type:\nlist\\[float]\nquaternion\\_mult(*\\*quats*)[\\[source]](../_modules/manim/utils/space_ops.html#quaternion_mult)[¶](#manim.utils.space_ops.quaternion_mult \"Link to this definition\")\nGets the Hamilton product of the quaternions provided.\nFor more information, check [this Wikipedia page](https://en.wikipedia.org/wiki/Quaternion).\nReturns:\nReturns a list of product of two quaternions.\nReturn type:\n[Union](manim.mobject.geometry.boolean_ops.Union.html#manim.mobject.geometry.boolean_ops.Union \"manim.mobject.geometry.boolean_ops.Union\")\\[np.ndarray, List\\[[Union](manim.mobject.geometry.boolean_ops.Union.html#manim.mobject.geometry.boolean_ops.Union \"manim.mobject.geometry.boolean_ops.Union\")\\[float, np.ndarray]]]\nParameters:\n**quats** (*Sequence**\\[**float**]*)\nregular\\_vertices(*n*, *\\**, *radius\\=1*, *start\\_angle\\=None*)[\\[source]](../_modules/manim/utils/space_ops.html#regular_vertices)[¶](#manim.utils.space_ops.regular_vertices \"Link to this definition\")\nGenerates regularly spaced vertices around a circle centered at the origin.\nParameters:\n* **n** (*int*) – The number of vertices\n* **radius** (*float*) – The radius of the circle that the vertices are placed on.\n* **start\\_angle** (*float* *\\|* *None*) – The angle the vertices start at.\nIf unspecified, for even `n` values, `0` will be used.\nFor odd `n` values, 90 degrees is used.\nReturns:\n* **vertices** (`numpy.ndarray`) – The regularly spaced vertices.\n* **start\\_angle** (`float`) – The angle the vertices start at.\nReturn type:\ntuple\\[*ndarray*, float]\nrotate\\_vector(*vector*, *angle*, *axis\\=array(\\[0\\., 0\\., 1\\.])*)[\\[source]](../_modules/manim/utils/space_ops.html#rotate_vector)[¶](#manim.utils.space_ops.rotate_vector \"Link to this definition\")\nFunction for rotating a vector.\nParameters:\n* **vector** (*ndarray*) – The vector to be rotated.\n* **angle** (*float*) – The angle to be rotated by.\n* **axis** (*ndarray*) – The axis to be rotated, by default OUT\nReturns:\nThe rotated vector with provided angle and axis.\nReturn type:\nnp.ndarray\nRaises:\n**ValueError** – If vector is not of dimension 2 or 3\\.\nrotation\\_about\\_z(*angle*)[\\[source]](../_modules/manim/utils/space_ops.html#rotation_about_z)[¶](#manim.utils.space_ops.rotation_about_z \"Link to this definition\")\nReturns a rotation matrix for a given angle.\nParameters:\n**angle** (*float*) – Angle for the rotation matrix.\nReturns:\nGives back the rotated matrix.\nReturn type:\nnp.ndarray\nrotation\\_matrix(*angle*, *axis*, *homogeneous\\=False*)[\\[source]](../_modules/manim/utils/space_ops.html#rotation_matrix)[¶](#manim.utils.space_ops.rotation_matrix \"Link to this definition\")\nRotation in R^3 about a specified axis of rotation.\nParameters:\n* **angle** (*float*)\n* **axis** (*ndarray*)\n* **homogeneous** (*bool*)\nReturn type:\n*ndarray*\nrotation\\_matrix\\_from\\_quaternion(*quat*)[\\[source]](../_modules/manim/utils/space_ops.html#rotation_matrix_from_quaternion)[¶](#manim.utils.space_ops.rotation_matrix_from_quaternion \"Link to this definition\")\nParameters:\n**quat** (*ndarray*)\nReturn type:\n*ndarray*\nrotation\\_matrix\\_transpose(*angle*, *axis*)[\\[source]](../_modules/manim/utils/space_ops.html#rotation_matrix_transpose)[¶](#manim.utils.space_ops.rotation_matrix_transpose \"Link to this definition\")\nParameters:\n* **angle** (*float*)\n* **axis** (*ndarray*)\nReturn type:\n*ndarray*\nrotation\\_matrix\\_transpose\\_from\\_quaternion(*quat*)[\\[source]](../_modules/manim/utils/space_ops.html#rotation_matrix_transpose_from_quaternion)[¶](#manim.utils.space_ops.rotation_matrix_transpose_from_quaternion \"Link to this definition\")\nConverts the quaternion, quat, to an equivalent rotation matrix representation.\nFor more information, check [this page](https://in.mathworks.com/help/driving/ref/quaternion.rotmat.html).\nParameters:\n**quat** (*ndarray*) – The quaternion which is to be converted.\nReturns:\nGives back the Rotation matrix representation, returned as a 3\\-by\\-3\nmatrix or 3\\-by\\-3\\-by\\-N multidimensional array.\nReturn type:\nList\\[np.ndarray]\nshoelace(*x\\_y*)[\\[source]](../_modules/manim/utils/space_ops.html#shoelace)[¶](#manim.utils.space_ops.shoelace \"Link to this definition\")\n2D implementation of the shoelace formula.\nReturns:\nReturns signed area.\nReturn type:\n`float`\nParameters:\n**x\\_y** ([*Point2D\\_Array*](manim.typing.html#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\"))\nshoelace\\_direction(*x\\_y*)[\\[source]](../_modules/manim/utils/space_ops.html#shoelace_direction)[¶](#manim.utils.space_ops.shoelace_direction \"Link to this definition\")\nUses the area determined by the shoelace method to determine whether\nthe input set of points is directed clockwise or counterclockwise.\nReturns:\nEither `\"CW\"` or `\"CCW\"`.\nReturn type:\n`str`\nParameters:\n**x\\_y** ([*Point2D\\_Array*](manim.typing.html#manim.typing.Point2D_Array \"manim.typing.Point2D_Array\"))\nspherical\\_to\\_cartesian(*spherical*)[\\[source]](../_modules/manim/utils/space_ops.html#spherical_to_cartesian)[¶](#manim.utils.space_ops.spherical_to_cartesian \"Link to this definition\")\nReturns a numpy array `[x, y, z]` based on the spherical\ncoordinates given.\nParameters:\n**spherical** (*Sequence**\\[**float**]*) – A list of three floats that correspond to the following:\nr \\- The distance between the point and the origin.\ntheta \\- The azimuthal angle of the point to the positive x\\-axis.\nphi \\- The vertical angle of the point to the positive z\\-axis.\nReturn type:\n*ndarray*\nthick\\_diagonal(*dim*, *thickness\\=2*)[\\[source]](../_modules/manim/utils/space_ops.html#thick_diagonal)[¶](#manim.utils.space_ops.thick_diagonal \"Link to this definition\")\nParameters:\n* **dim** (*int*)\n* **thickness** (*int*)\nReturn type:\n[*MatrixMN*](manim.typing.html#manim.typing.MatrixMN \"manim.typing.MatrixMN\")\nz\\_to\\_vector(*vector*)[\\[source]](../_modules/manim/utils/space_ops.html#z_to_vector)[¶](#manim.utils.space_ops.z_to_vector \"Link to this definition\")\nReturns some matrix in SO(3\\) which takes the z\\-axis to the\n(normalized) vector provided as an argument\nParameters:\n**vector** (*ndarray*)\nReturn type:\n*ndarray*",
  "scraped_at": "2025-06-24T18:36:52.059507",
  "content_length": 17925,
  "domain": "docs.manim.community",
  "word_count": 1581,
  "inspection_status": "pending",
  "filename": "space_ops - Manim Community v0.19.0_20250624_183652.json",
  "saved_at": "2025-06-24T18:36:52.059608"
}